<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git学习]]></title>
    <url>%2F2018%2F07%2F23%2Fgit%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[简介 Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 安装Git 目前支持 Linux/Unix、Solaris、Mac和 Windows 平台上运行。Git 各平台安装包下载地址为：http://git-scm.com/downloads liunx（Debian/Ubuntu）下下载：12apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \libz-dev libssl-dev liunx（Centos/RedHat）12apt-get install gityum -y install git-core 配置 配置个人的用户名称和电子邮件地址： 12git config --global user.name "yourname"git config --global user.email youremail@runoob.com 查看配置信息 1git config --list 检查版本 1git --version]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用HashMap实现简单的倒排索引]]></title>
    <url>%2F2018%2F07%2F20%2F%E7%94%A8HashMap%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[简述搜索引擎通常检索的场景是：给定几个关键词，找出包含关键词的文档用HashMap实现倒排索引的设想： 举例 有三本书，每本书中都会有几个关键字，通过关键字来检索到出现在那几本书中 实行：创建两个hashmap，一个用来存放原数据，一个用来存放新索引，以原数据的value分割后的单词做新索引的key，以原数据的value对应的key做索引value，添加到新索引中 实现 123456789101112131415161718192021222324252627282930313233343536373839public static void main(String[] args) &#123; //存储数据map HashMap date = new HashMap(); date.put("book1","hello world"); date.put("book2","hello beautiful world"); date.put("book3","hello beautiful new world"); //索引的map HashMap index = new HashMap(); Set keySet = date.keySet(); //遍历date的key for (Object word:keySet) &#123; String keyString = (String) word; //通过key获得value String count = (String) date.get(keyString); //将字符串分割成数组 String[] words = count.split(" "); //遍历数组，获取关键字 for (int i = 0; i &lt;words.length ; i++) &#123; //判断索引中是否存在关键字，如果不存在添加，存在将追加 if (!index.containsKey(words[i]))&#123; //创建一个arrylist用来添加或后续追加索引值 ArrayList books = new ArrayList(); //将date的key存入 books.add(keyString); //将新组建的键值对存入索引 index.put(words[i],books); &#125; else &#123; //如果存在关键字,通过关键字获取value， List books = (List) index.get(words[i]); //将date的key追加到value中 books.add(keyString); &#125; &#125; &#125; //输出新map System.out.println(index); &#125; 输出结果 123&#123;beautiful=[book2, book3], new=[book3], world=[book2, book1, book3], hello=[book2, book1, book3]&#125;Process finished with exit code 0]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础笔记整理]]></title>
    <url>%2F2018%2F07%2F19%2Fjava%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[java基础易错知识整理数组初始值下面代码输出结果是0 1234public static void main(String[] args) &#123; int[] arry=new int[10]; Sysout.out.println(arr[i]); &#125; –int类型：0 –short类型：(short）0 –byte类型：(byte）0 –long类型：0L –doulbe类型：0.0d –float类型：0.0f –char类型：\u0000（空格字符） –boolean类型：false–引用类型的数组在创建之后，赋默认值null throw和throws的区别抛出异常有三种形式，一是throw,一个throws，还有一种系统自动抛异常。下面它们之间的异同 当程序语句出现一些逻辑错误、主义错误或类型转换错误时，系统会自动抛出异常 123456 public static void main(String[] args) &#123; int a = 5, b =0; System.out.println(5/b); //function(); &#125; throw是语句抛出一个异常，一般是在代码块的内部，当程序出现某种逻辑错误时由程序员主动抛出某种特定类型的异常 12345678910public static void main(String[] args) &#123; String s = "abc"; if(s.equals("abc")) &#123; throw new NumberFormatException(); &#125; else &#123; System.out.println(s); &#125; &#125; throws是方法可能抛出异常的声明。(用在声明方法时，表示该方法可能要抛出异常) public void function() throws Exception{……} 当某个方法可能会抛出某种异常时用于throws 声明可能抛出的异常，然后交给上层调用它的方法程序处理 123456789101112131415 public class testThrows()&#123;public static void function() throws NumberFormatException&#123; String s = "abc"; System.out.println(Double.parseDouble(s)); &#125; public static void main(String[] args) &#123; try &#123; function(); &#125; catch (NumberFormatException e) &#123; System.err.println("非数据类型不能强制类型转换。"); //e.printStackTrace(); &#125; &#125; throw与throws的比较1、throws出现在方法函数头；而throw出现在函数体。2、throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。3、两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。参考自 ：https://blog.csdn.net/hjfcgt123/article/details/53349275 堆溢出和栈溢出 栈溢出(StackOverflowError) 堆溢出(OutOfMemoryError:java heap space)先了解一下java中的堆和栈，JAVA在程序运行时，在内存中划分5片空间进行数据的存储。分别是：1：寄存器。2：本地方法区。3：方法区。4：栈。5：堆。 基本数据类型、局部变量都是存放在栈内存中的，用完就消失。new创建的实例化对象及数组，是存放在堆内存中的，用完之后靠垃圾回收机制不定期自动消除。举个例子ArrayList list = new ArrayList(); 实际上，在创建完上面的一个对象后，在JVM中，会把new出来的对象存放在堆内存中， 同时，在方法栈中存放着对象的引用关系。 如果想要堆溢出，比较简单，可以循环创建对象或大的对象；死循环创建字符串对象或字符串拼接。 123456789101112131415public static void main(String[] args) &#123; ArrayList list=new ArrayList(); while(true) &#123; list.add(new Heap()); &#125; &#125; 如果想要栈溢出，可以递归调用方法，这样随着栈深度的增加，JVM 维持着一条长长的方法调用轨迹，直到内存不够分配，产生栈溢出。123456789101112131415public static void main(String[] args) &#123; new Stack().test(); &#125; public void test() &#123; test(); &#125; String和StringBuffer，StringBuilder区别这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面 首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; StringString最慢的原因： **String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。**12345public static void main(String[] args) &#123; String str="abc"; System.out.println(str); str=str+"de"; System.out.println(str); 如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。 而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多123456public static void main(String[] args) &#123; String str="abc"+"de"; StringBuilder stringBuilder=new StringBuilder().append("abc").append("de"); System.out.println(str); System.out.println(stringBuilder.toString()); &#125;这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多 在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的 如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。来自：https://www.cnblogs.com/su-feng/p/6659064.html Java中==号与equals()方法的区别 首先==号在比较基本数据类型时比较的是值，而用==号比较两个对象时比较的是两个对象的地址值：12345678public static void main(String[] args) &#123; int x = 10; int y = 10; String str1 = new String("abc"); String str2 = new String("abc"); System.out.println(x == y); // 输出true System.out.println(str1 == str2); // 输出false &#125; Equals是object中的方法，用于判断两个对象是否想等。默认的equals是== ,不过子类可以重写父类的方法，加以改变。典型如string integer等类都重写了equals方法ArrayList和LinkedList的区别 一个是Array(动态数组)的数据结构，一个是Link(链表)的数据结构，此外，它们两个都是对List接口的实现。前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列 当随机访问List时（get和set操作），ArrayList比LinkedList的效率更高，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找 当对数据进行增加和删除的操作时(add和remove操作)，LinkedList比ArrayList的效率更高，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动 从利用效率来看，ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。 ArrayList主要控件开销在于需要在List列表预留一定空间；而LinkList主要控件开销在于需要存储结点信息以及结点指针信息。来自于：https://www.cnblogs.com/Amedeo/p/7885146.html运行时异常和受检时异常区别最本质的区别是RuntimeException是运行时才会发生的异常, 而受检查异常是编译时异常,编译器会分析哪些异常会在执行一个方法或者构造函数的时候抛出。 运行时异常（RuntimeException）也称作未检测的异常（unchecked exception），这表示这种异常不需要编译器来检测。RuntimeException是所有可以在运行时抛出的异常的父类。一个方法除要捕获异常外，如果它执行的时候可能会抛出RuntimeException的子类，那么它就不需要用throw语句来声明抛出的异常 受检查异常（checked exception）都是编译器在编译时进行校验的，通过throws语句或者try{}cathch{} 语句块来处理检测异常。编译器会分析哪些异常会在执行一个方法或者构造函数的时候抛出。待续………]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符编码]]></title>
    <url>%2F2018%2F07%2F18%2F%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[常用字符编码分类 字符集编码：就是用数字来表示各种字符 asc码：美国国家标准码一个字节表示一个字符 UTF：unicode世界范围的统一编码用四个字节表示一个字符UTF-8:优化以后的utf码。让英文语系的编码量明显减少，有保证了世界范围的通用 GBK：汉字内码扩展规范 Big5：在台湾、香港与澳门地区，使用的是繁体中文字符集 总结 1、编码界最初只有ASCII码，只用了1byte中的7bit（0~127）； 2、欧洲人发现128个不够了，就把1byte中没用的最高位给用上了，出现了Latin系列（ISO-8859系列）编码； 3、中国人民通过对ASCII编码进行中文扩充改造，产生了GB2312编码，可以表示6000多个常用汉字； 4、汉字实在太多了，还有繁体、各种字符呀，于是加以扩展，有了GBK； 5、GBK还不够，少数民族的字还木有呀，于是GBK又扩展为GB18030； 6、每个国家、语言都有自己的编码，彼此无法交流，迫切需要大一统局面的出现； 7、Unicode诞生，可以容纳全世界的任何文字。Unicode分为UCS-2和UCS-4，分别是2字节和4字节，实际2字节就够用了； 8、为了Unicode能实际应用（存储、传输），制定了Unicode的编码方式，即UTF，有UTF-8、UTF-16、UTF-32，其中UTF-8应用广泛； 9、UTF-16、UTF-32均是多字节传输，存在字节顺序的问题，于是有了大头还是小头的概念，为了解决这个问题，引入了BOM。UTF-8是单字节传输，不存在这个问题，也就不需要BOM，但可以有，仅用来表明编码格式； 10、要从“环境/终端/文本/程序”等不同层次去理解编码，并尝试解决遇到的问题； 在线编码转换工具http://tool.chinaz.com/Tools/Unicode.aspx]]></content>
  </entry>
  <entry>
    <title><![CDATA[内部类]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[#定义：在一个类的内部又定义了一个类，这就是内部类。#举例：12345678public class OuterClass &#123; private String outerName; private int outerAge; public class InnerClass&#123; private String innerName; private int innerAge; &#125; &#125; 内部类是一个编译时概念，编译后外部类及其内部类会生成两个独立的class文件： OuterClass.class和OuterClass$InnerClass.class内部类可以直接访问外部类的元素，但是外部类不可以直接访问内部类的元素 表现形式 静态内部类 关键字static可以修饰成员变量、方法、代码块，其实它还可以修饰内部类，使用static修饰的内部类我们称之为静态内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着： 静态内部类的创建是不需要依赖于外围类，可以直接创建静态内部类不可以使用任何外围类的非static成员变量和方法，而内部类则都可以 成员内部类 成员内部类也是最普通的内部类，它是外部类的一个成员，所以他是可以无限制的访问外围类的所有成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。 在成员内部类中要注意两点： 成员内部类中不能存在任何static的变量和方法成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类 局部内部类 有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。 匿名内部类 匿名内部类其实就是一个没有名字的方法内部类，所以它符合方法内部类的所有约束，初次之外，还有一些地方需要注意： 匿名内部类是没有访问修饰符的。匿名内部类必须继承一个抽象类或者实现一个接口匿名内部类中不能存在任何静态成员或方法匿名内部类是没有构造方法的，因为它没有类名。一般使用匿名内部类的场景是，要继承或实现的接口只有一个抽象方法，比如添加一个监听器 特点为什么要使用内部类？在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。⒈ 内部类对象可以访问创建它的对象的实现，包括私有数据；⒉ 内部类不为同一包的其他类所见，具有很好的封装性；⒊ 使用内部类可以很方便的编写事件驱动程序；⒋ 匿名内部类可以方便的定义运行时回调；5.内部类可以方便的定义 匿名内部类匿名内部类的创建方式1234new 父类构造器（参数列表）|实现接口（） &#123; //匿名内部类的类体部分 &#125; 使用匿名内部类我们必须要继承一个父类或者实现一个接口,这是因为匿名内部类是直接使用new来生成一个对象的引用。当然这个引用是隐式的1234567891011public class Anonymous &#123; //测试匿名内部类 public static void main(String[] args) &#123; Inner inner = new Inner() &#123; @Override public String getName() &#123; return "tom"; &#125; &#125;; System.out.println(inner.getName()); 在使用匿名内部类的过程中，我们需要注意如下几点： 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。 匿名内部类中是不能定义构造函数的。 匿名内部类中不能存在任何的静态成员变量和静态方法。 匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java单例模式]]></title>
    <url>%2F2018%2F07%2F14%2Fjava%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式概述 单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例 Java中单例模式定义：“一个类有且仅有一个实例，并且自行实例化向整个系统提供。” 单例模式三要素： 私有的构造方法； 指向自己实例的私有静态引用； 以自己实例为返回值的静态的公有方法。 单例模式实现 单例模式可以分为懒汉式和饿汉式： 懒汉式单例模式：在类加载时不初始化。饿汉式单例模式：在类加载时就完成了初始化，所以类加载比较慢，但获取对象的速度快。 第一种（懒汉，线程不安全）12345678910public class SingletonDemo &#123; private static SingletonDemo instance; private SingletonDemo1()&#123;&#125; public static SingletonDemo1 getInstance()&#123; if (instance == null) &#123; instance = new SingletonDemo1(); &#125; return instance; &#125; &#125; 第二种（懒汉，线程安全）1234567891011public class SingletonDemo &#123; public class SingletonDemo &#123; private static SingletonDemo instance; private SingletonDemo2()&#123;&#125; public static synchronized SingletonDemo2 getInstance()&#123; if (instance == null) &#123; instance = new SingletonDemo2(); &#125; return instance; &#125; &#125; 第三种（饿汉）12345678public class SingletonDemo &#123; public class SingletonDemo &#123; private static SingletonDemo instance = new SingletonDemo3(); private SingletonDemo3()&#123;&#125; public static SingletonDemo3 getInstance()&#123; return instance; &#125; &#125; 单例模式优缺点 优点： 在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例 单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。 提供了对唯一实例的受控访问。 由于在系统内存中只存在一个对象，因此可以 节约系统资源，当 需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。 允许可变数目的实例。 避免对共享资源的多重占用。 缺点 不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。 由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。 单例类的职责过重，在一定程度上违背了“单一职责原则”。 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。使用场景由于单例模式具有以上优点，并且形式上比较简单，所以是日常开发中用的比较多的一种设计模式，其核心在于为整个系统提供一个唯一的实例，其应用场景包括但不仅限于以下几种： 有状态的工具类对象； 频繁访问数据库或文件的对象；我的cnds：https://blog.csdn.net/qq_38384971]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[text]]></title>
    <url>%2F2018%2F07%2F14%2Ftext%2F</url>
    <content type="text"><![CDATA[下载图片 点击加载下载文档点击下载 Think In Java在线 测试1测试2###测试3 ####测试4 代码测试public static void main(String[] args) { MyLinkList myLinkList = new MyLinkList(); for (int i = 0; i &lt; 100; i++) { myLinkList.add(i); } public static void main(String[] args) { MyLinkList myLinkList = new MyLinkList(); for (int i = 0; i &lt; 100; i++) { myLinkList.add(i);ll } 测试yLinkList.add(i); 序列测试 测试 cs 测试 测试 测试测试测试分页测试 代码类型测试12345public static void main(String[] args) &#123; MyLinkList myLinkList = new MyLinkList(); for (int i = 0; i &lt; 100; i++) &#123; myLinkList.add(i); &#125; [] [title] [url] [link text]123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*- # 定义函数def printme( str ): "打印任何传入的字符串" print str; return; # 调用函数printme("我要调用用户自定义函数!");printme("再次调用同一函数"); [] [title] [url] [link text]1234567var w=window.innerWidth|| document.documentElement.clientWidth|| document.body.clientWidth;var h=window.innerHeight|| document.documentElement.clientHeight|| document.body.clientHeight; [] [title] [url] [link text]12345678&lt;div id="bpn"&gt;&lt;ul class="prenext"&gt;&lt;li class="pre"&gt;&lt;a href="/js/js_obj_regexp.asp" title="JavaScript RegExp 对象"&gt;JS 正则表达式&lt;/a&gt;&lt;/li&gt;&lt;li class="next"&gt;&lt;a href="/js/js_window_screen.asp" title="JavaScript Window Screen"&gt;JS Screen&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt; [lang:] [title] [url] [link text]1 2018/7/14 16:55:56]]></content>
  </entry>
  <entry>
    <title><![CDATA[链表的java实现]]></title>
    <url>%2F2018%2F07%2F13%2F%E9%93%BE%E8%A1%A8%E7%9A%84java%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[创建一个节点和一个对象 节点包含两个属性：数据，和指向连接对象实现添加和查询方法 ##创建节点1234567891011121314151617181920212223public class Node &#123; private int date; private Node next; public int getDate() &#123; return date; &#125; public void setDate(int date) &#123; this.date = date; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node next) &#123; this.next = next; &#125; &#125; ##创建对象1234567891011121314151617181920212223242526272829public class MyLinkList &#123; private Node head=new Node(); private Node tail=head; //定义存放数据方法 public void add(int num)&#123; //创建一个节点，将数据填充到节点，将尾部节点指向新创建的节点 Node node=new Node(); //将数据填充节点 node.setDate(num); tail.setNext(node); tail=node; &#125; //定义get方法 public int get(int index)&#123; Node target=head; for (int i = 0; i &lt; index+1; i++) &#123; target=target.getNext(); &#125; return target.getDate(); &#125; public static void main(String[] args) &#123; MyLinkList myLinkList = new MyLinkList(); for (int i = 0; i &lt; 100; i++) &#123; myLinkList.add(i); &#125; System.out.println(myLinkList.get(1)); &#125; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
</search>
