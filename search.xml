<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[40个多线程问题总结]]></title>
    <url>%2F2018%2F07%2F30%2F40%E4%B8%AA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[多线程有什么用？（1）发挥多核CPU的优势 随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。 （2）防止阻塞 从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。（3）便于建模 这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。 创建线程的方式比较常见的一个问题了，一般就是两种： （1）继承Thread类 （2）实现Runnable接口 至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。 start()方法和run()方法的区别只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。 Runnable接口和Callable接口的区别有点深的问题了，也看出一个Java程序员学习知识的广度。 Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。 这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。 CyclicBarrier和CountDownLatch的区别两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于： （1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行 （2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务 （3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了 Volatile关键字的作用一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个： （1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据 （2）代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率 从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。 什么是线程安全又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。 这个问题有值得一提的地方，就是线程安全也是有几个级别的： （1）不可变 像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用 （2）绝对线程安全 不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet （3）相对线程安全 相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。 （4）线程非安全 这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类 Java中如何获取到线程dump文件死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步： （1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java （2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid 另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈， 一个线程如果出现了运行时异常会怎么样如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放 如何在两个线程之间共享数据通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的 sleep方法和wait方法有什么区别这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器 生产者消费者模型的作用是什么这个问题很理论，但是很重要： （1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用 （2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约 ThreadLocal有什么用简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了 为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁 wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。 为什么要使用线程池避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。 怎么检测一个线程是否持有对象监视器我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着“某条线程”指的是当前线程。 synchronized和ReentrantLock的区别synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： （1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 （2）ReentrantLock可以获取各种锁的信息 （3）ReentrantLock可以灵活地实现多路通知 另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。 ConcurrentHashMap的并发度是什么ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？ ReadWriteLock是什么首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。 因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。 FutureTask是什么这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。 Linux环境下如何查找哪个线程使用CPU最长这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做： （1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过 （2）top -H -p pid，顺序不能改变 这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。 使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。 最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。 Java编程写一个会导致死锁的程序第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。 真正理解什么是死锁，这个问题其实不难，几个步骤： （1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁； （2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁 （3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的 这样，线程1″睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，Java多线程7：死锁这篇文章里面有，就是上面步骤的代码实现。 怎么唤醒一个阻塞的线程如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。 不可变对象对多线程有什么帮助前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。 什么是多线程的上下文切换多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。 如果你提交任务时，线程池队列已满，这时会发生什么如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务；如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。 Java中用到的线程调度算法是什么抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。 Thread.sleep(0)的作用是什么这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。 什么是自旋很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行地非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。 什么是Java内存模型Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容： （1）Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去 （2）定义了几个原子操作，用于操作主内存和工作内存中的变量 （3）定义了volatile变量的使用规则 （4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的 什么是CASCAS，全称为Compare and Set，即比较-设置。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。 什么是乐观锁和悲观锁（1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-设置这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。 （2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。 什么是AQS简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。 如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。 AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。 单例模式的线程安全性老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下： （1）饿汉式单例模式的写法：线程安全 （2）懒汉式单例模式的写法：非线程安全 （3）双检锁单例模式的写法：线程安全 Semaphore有什么作用Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。 Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？ 关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点： （1）同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性 （2）CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成汇编代码执行的，汇编代码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句”return count”假设被翻译成了三句汇编语句执行，完全可能执行完第一句，线程就切换了。 线程类的构造方法、静态块是被哪个线程调用的这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。 如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么： （1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的 （2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的 同步方法和同步块，哪个是更好的选择同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越少越好。 借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。 高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是： （1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换 （2）并发不高、任务执行时间长的业务要区分开看： a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务 b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换 （3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。 转载自 https://www.cnblogs.com/Java3y/p/8999199.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[java基础练习题]]></title>
    <url>%2F2018%2F07%2F25%2Fjava%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.字符串排序1234567891011121314151617181920public static void main(String[] args) &#123; //给定一字符串，进行排序 String str = "hello"; char[] chars = str.toCharArray(); char temp=' '; for (int i = 0; i &lt; chars.length; i++) &#123; for (int j = 0; j &lt;i ; j++) &#123; if (chars[i]&lt;chars[j])&#123; temp=chars[i]; chars[i]=chars[j]; chars[j]=temp; &#125; &#125; &#125; //第二种方法，利用工具类 Arrays.sort(chars); System.out.println(chars); &#125; 字符串，将其首字母转为大写，后续字母转为小写输出。1234567public static void main(String[] args) &#123; //给定任意字符串，将其首字母转为大写，后续字母转为小写输出。 String str="helLOBaby"; String s1 = str.substring(0, 1).toUpperCase(); String s2 = str.substring(1).toLowerCase(); System.out.println(s1+s2); &#125; 彩票问题 有一个股票价格序列共10天。每天的价格是{4，2，1，3，5，7，5，7，8，8}。规定：3日移动平均价格大于当天价格则买入。请问第一次出现买入信号是第几天，总共出现几次买入信号。提示：3日移动平均是指当前以及以后两天的价格的平均值。 1234567891011121314151617public static void main(String[] args) &#123; int arry[]=&#123;4,2,1,3,5,7,5,7,8,8&#125;; int days=0; int count=0; for (int i = 0; i &lt; arry.length-2; i++) &#123; double avg=(arry[i]+arry[i+1]+arry[i+2])/3.0; if (arry[i]&lt;avg)&#123; count++; if (count==1)&#123; System.out.println("第"+(i+1)+"天"); &#125; &#125; &#125; System.out.println("一共出现五次"+count); &#125; 用蒙特卡洛模拟求出圆周率12345678910111213141516171819202122232425static double MontePI(int n) &#123; double PI; double x, y; int i, sum; sum = 0; for (i = 1; i &lt; n; i++) &#123; x = Math.random(); y = Math.random(); if ((x * x + y * y) &lt;= 1) &#123; sum++; &#125; &#125; PI = 4.0 * sum / n; return PI; &#125; public static void main(String[] args) &#123; int n; double PI; System.out.println("蒙特卡洛概率算法计算圆周率:"); Scanner input = new Scanner(System.in); System.out.println("输入点的数量："); n = input.nextInt(); PI = MontePI(n); System.out.println("PI="+PI); &#125; 求出字符不同字母的个数123456789101112public static void main(String[] args) &#123; //求出字符不同字母的个数 String str=""; String str3="hello"; for (int i = 0; i &lt; str3.length(); i++) &#123; String ch=str3.substring(i,i+1); if (!str.contains(ch))&#123; str+=ch; &#125; &#125; System.out.println(str.length()); &#125; 判断字符串是否对称123456789101112131415161718192021public static void main(String[] args) &#123; //判断字符串是否对称 boolean flag = false; Scanner s = new Scanner(System.in); System.out.println("请输入一个字符串"); String str = s.next(); char ch[] = str.toCharArray(); for (int i = 0; i &lt; ch.length / 2; i++) &#123; if (ch[i] != ch[ch.length - i - 1]) &#123; flag = false; break; &#125; else &#123; continue; &#125; &#125; if (flag) &#123; System.out.println("yes"); &#125; else &#123; System.out.println("no"); &#125; &#125; 创建一个可以无限存放数组的容器123456789101112131415161718192021222324252627282930313233343536public class MyArryList &#123; //创建一个可以无限存放数组的容器 private int size=16; private int[] init=new int[size]; private int index=0; //从集合中取 public int get(int index)&#123; if (index&lt;0)&#123; System.out.println("下标不能小于0"); return -1; &#125; return init[index]; &#125; public void add(int num)&#123; if (index&gt;size*0.75)&#123; size*=2; //创建两倍大小数组 int []newArry=new int[size]; //遍历老数组,复制到新数组中 for (int i = 0; i &lt; init.length; i++) &#123; newArry[i]=init[i]; &#125; init=newArry; &#125; init[index]=num; index++; &#125; public static void main(String[] args) &#123; MyArryList myArryList = new MyArryList(); for (int i = 0; i &lt;200 ; i++) &#123; myArryList.add(i); &#125; System.out.println(myArryList.get(18)); &#125; 链表的实现原理12345678910111213141516171819202122public class Node &#123; //存放数据 private int date; //指向下一个节点个引用 private Node next; public int getDate() &#123; return date; &#125; public void setDate(int date) &#123; this.date = date; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node next) &#123; this.next = next; &#125;&#125; 1234567891011121314151617181920212223242526272829303132public class MyLinkList &#123; private Node head=new Node(); private Node tail=head; //定义存放数据方法 public void add(int num)&#123; //创建一个节点，将数据填充到节点，将尾部节点指向新创建的节点 Node node=new Node(); //将数据填充节点 node.setDate(num); //然后将 // Node next=tail.getNext(); tail.setNext(node); tail=node; &#125; //定义get方法 public int get(int index)&#123; Node target=head; for (int i = 0; i &lt; index+1; i++) &#123; target=target.getNext(); &#125; return target.getDate(); &#125; public static void main(String[] args) &#123; MyLinkList myLinkList = new MyLinkList(); for (int i = 0; i &lt; 100; i++) &#123; myLinkList.add(i); &#125; System.out.println(myLinkList.get(5)); &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习]]></title>
    <url>%2F2018%2F07%2F23%2Fgit%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[简介 Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 安装Git 目前支持 Linux/Unix、Solaris、Mac和 Windows 平台上运行。Git 各平台安装包下载地址为：http://git-scm.com/downloads liunx（Debian/Ubuntu）下下载：12apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \libz-dev libssl-dev liunx（Centos/RedHat）12apt-get install gityum -y install git-core 配置 配置个人的用户名称和电子邮件地址： 12git config --global user.name "yourname"git config --global user.email youremail@runoob.com 查看配置信息 1git config --list 检查版本 1git --version]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用HashMap实现简单的倒排索引]]></title>
    <url>%2F2018%2F07%2F20%2F%E7%94%A8HashMap%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[简述搜索引擎通常检索的场景是：给定几个关键词，找出包含关键词的文档用HashMap实现倒排索引的设想： 举例 有三本书，每本书中都会有几个关键字，通过关键字来检索到出现在那几本书中 实行：创建两个hashmap，一个用来存放原数据，一个用来存放新索引，以原数据的value分割后的单词做新索引的key，以原数据的value对应的key做索引value，添加到新索引中 实现 123456789101112131415161718192021222324252627282930313233343536373839public static void main(String[] args) &#123; //存储数据map HashMap date = new HashMap(); date.put("book1","hello world"); date.put("book2","hello beautiful world"); date.put("book3","hello beautiful new world"); //索引的map HashMap index = new HashMap(); Set keySet = date.keySet(); //遍历date的key for (Object word:keySet) &#123; String keyString = (String) word; //通过key获得value String count = (String) date.get(keyString); //将字符串分割成数组 String[] words = count.split(" "); //遍历数组，获取关键字 for (int i = 0; i &lt;words.length ; i++) &#123; //判断索引中是否存在关键字，如果不存在添加，存在将追加 if (!index.containsKey(words[i]))&#123; //创建一个arrylist用来添加或后续追加索引值 ArrayList books = new ArrayList(); //将date的key存入 books.add(keyString); //将新组建的键值对存入索引 index.put(words[i],books); &#125; else &#123; //如果存在关键字,通过关键字获取value， List books = (List) index.get(words[i]); //将date的key追加到value中 books.add(keyString); &#125; &#125; &#125; //输出新map System.out.println(index); &#125; 输出结果 123&#123;beautiful=[book2, book3], new=[book3], world=[book2, book1, book3], hello=[book2, book1, book3]&#125;Process finished with exit code 0]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础笔记整理]]></title>
    <url>%2F2018%2F07%2F19%2Fjava%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[java基础易错知识整理数组初始值下面代码输出结果是0 1234public static void main(String[] args) &#123; int[] arry=new int[10]; Sysout.out.println(arr[i]); &#125; –int类型：0 –short类型：(short）0 –byte类型：(byte）0 –long类型：0L –doulbe类型：0.0d –float类型：0.0f –char类型：\u0000（空格字符） –boolean类型：false–引用类型的数组在创建之后，赋默认值null，初始化后，int型默认值为0 throw和throws的区别抛出异常有三种形式，一是throw,一个throws，还有一种系统自动抛异常。下面它们之间的异同 当程序语句出现一些逻辑错误、主义错误或类型转换错误时，系统会自动抛出异常 123456 public static void main(String[] args) &#123; int a = 5, b =0; System.out.println(5/b); //function(); &#125; throw是语句抛出一个异常，一般是在代码块的内部，当程序出现某种逻辑错误时由程序员主动抛出某种特定类型的异常 12345678910public static void main(String[] args) &#123; String s = "abc"; if(s.equals("abc")) &#123; throw new NumberFormatException(); &#125; else &#123; System.out.println(s); &#125; &#125; throws是方法可能抛出异常的声明。(用在声明方法时，表示该方法可能要抛出异常) public void function() throws Exception{……} 当某个方法可能会抛出某种异常时用于throws 声明可能抛出的异常，然后交给上层调用它的方法程序处理 123456789101112131415 public class testThrows()&#123;public static void function() throws NumberFormatException&#123; String s = "abc"; System.out.println(Double.parseDouble(s)); &#125; public static void main(String[] args) &#123; try &#123; function(); &#125; catch (NumberFormatException e) &#123; System.err.println("非数据类型不能强制类型转换。"); //e.printStackTrace(); &#125; &#125; throw与throws的比较1、throws出现在方法函数头；而throw出现在函数体。2、throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。3、两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。参考自 ：https://blog.csdn.net/hjfcgt123/article/details/53349275 堆溢出和栈溢出 栈溢出(StackOverflowError) 堆溢出(OutOfMemoryError:java heap space)先了解一下java中的堆和栈，JAVA在程序运行时，在内存中划分5片空间进行数据的存储。分别是：1：寄存器。2：本地方法区。3：方法区。4：栈。5：堆。 基本数据类型、局部变量都是存放在栈内存中的，用完就消失。new创建的实例化对象及数组，是存放在堆内存中的，用完之后靠垃圾回收机制不定期自动消除。举个例子ArrayList list = new ArrayList(); 实际上，在创建完上面的一个对象后，在JVM中，会把new出来的对象存放在堆内存中， 同时，在方法栈中存放着对象的引用关系。 如果想要堆溢出，比较简单，可以循环创建对象或大的对象；死循环创建字符串对象或字符串拼接。 123456789101112131415public static void main(String[] args) &#123; ArrayList list=new ArrayList(); while(true) &#123; list.add(new Heap()); &#125; &#125; 如果想要栈溢出，可以递归调用方法，这样随着栈深度的增加，JVM 维持着一条长长的方法调用轨迹，直到内存不够分配，产生栈溢出。123456789101112131415public static void main(String[] args) &#123; new Stack().test(); &#125; public void test() &#123; test(); &#125; String和StringBuffer，StringBuilder区别这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面 首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; StringString最慢的原因： **String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。**12345public static void main(String[] args) &#123; String str="abc"; System.out.println(str); str=str+"de"; System.out.println(str); 如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。 而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多123456public static void main(String[] args) &#123; String str="abc"+"de"; StringBuilder stringBuilder=new StringBuilder().append("abc").append("de"); System.out.println(str); System.out.println(stringBuilder.toString()); &#125;这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多 在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的 如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。来自：https://www.cnblogs.com/su-feng/p/6659064.html Java中==号与equals()方法的区别 首先==号在比较基本数据类型时比较的是值，而用==号比较两个对象时比较的是两个对象的地址值：12345678public static void main(String[] args) &#123; int x = 10; int y = 10; String str1 = new String("abc"); String str2 = new String("abc"); System.out.println(x == y); // 输出true System.out.println(str1 == str2); // 输出false &#125; Equals是object中的方法，用于判断两个对象是否想等。默认的equals是== ,不过子类可以重写父类的方法，加以改变。典型如string integer等类都重写了equals方法ArrayList和LinkedList的区别 一个是Array(动态数组)的数据结构，一个是Link(链表)的数据结构，此外，它们两个都是对List接口的实现。前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列 当随机访问List时（get和set操作），ArrayList比LinkedList的效率更高，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找 当对数据进行增加和删除的操作时(add和remove操作)，LinkedList比ArrayList的效率更高，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动 从利用效率来看，ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。 ArrayList主要控件开销在于需要在List列表预留一定空间；而LinkList主要控件开销在于需要存储结点信息以及结点指针信息。来自于：https://www.cnblogs.com/Amedeo/p/7885146.html运行时异常和受检时异常区别最本质的区别是RuntimeException是运行时才会发生的异常, 而受检查异常是编译时异常,编译器会分析哪些异常会在执行一个方法或者构造函数的时候抛出。 运行时异常（RuntimeException）也称作未检测的异常（unchecked exception），这表示这种异常不需要编译器来检测。RuntimeException是所有可以在运行时抛出的异常的父类。一个方法除要捕获异常外，如果它执行的时候可能会抛出RuntimeException的子类，那么它就不需要用throw语句来声明抛出的异常 受检查异常（checked exception）都是编译器在编译时进行校验的，通过throws语句或者try{}cathch{} 语句块来处理检测异常。编译器会分析哪些异常会在执行一个方法或者构造函数的时候抛出。待续………]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符编码]]></title>
    <url>%2F2018%2F07%2F18%2F%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[常用字符编码分类 字符集编码：就是用数字来表示各种字符 asc码：美国国家标准码一个字节表示一个字符 UTF：unicode世界范围的统一编码用四个字节表示一个字符UTF-8:优化以后的utf码。让英文语系的编码量明显减少，有保证了世界范围的通用 GBK：汉字内码扩展规范 Big5：在台湾、香港与澳门地区，使用的是繁体中文字符集 总结 1、编码界最初只有ASCII码，只用了1byte中的7bit（0~127）； 2、欧洲人发现128个不够了，就把1byte中没用的最高位给用上了，出现了Latin系列（ISO-8859系列）编码； 3、中国人民通过对ASCII编码进行中文扩充改造，产生了GB2312编码，可以表示6000多个常用汉字； 4、汉字实在太多了，还有繁体、各种字符呀，于是加以扩展，有了GBK； 5、GBK还不够，少数民族的字还木有呀，于是GBK又扩展为GB18030； 6、每个国家、语言都有自己的编码，彼此无法交流，迫切需要大一统局面的出现； 7、Unicode诞生，可以容纳全世界的任何文字。Unicode分为UCS-2和UCS-4，分别是2字节和4字节，实际2字节就够用了； 8、为了Unicode能实际应用（存储、传输），制定了Unicode的编码方式，即UTF，有UTF-8、UTF-16、UTF-32，其中UTF-8应用广泛； 9、UTF-16、UTF-32均是多字节传输，存在字节顺序的问题，于是有了大头还是小头的概念，为了解决这个问题，引入了BOM。UTF-8是单字节传输，不存在这个问题，也就不需要BOM，但可以有，仅用来表明编码格式； 10、要从“环境/终端/文本/程序”等不同层次去理解编码，并尝试解决遇到的问题； 在线编码转换工具http://tool.chinaz.com/Tools/Unicode.aspx]]></content>
  </entry>
  <entry>
    <title><![CDATA[内部类]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[#定义：在一个类的内部又定义了一个类，这就是内部类。#举例：12345678public class OuterClass &#123; private String outerName; private int outerAge; public class InnerClass&#123; private String innerName; private int innerAge; &#125; &#125; 内部类是一个编译时概念，编译后外部类及其内部类会生成两个独立的class文件： OuterClass.class和OuterClass$InnerClass.class内部类可以直接访问外部类的元素，但是外部类不可以直接访问内部类的元素 表现形式 静态内部类 关键字static可以修饰成员变量、方法、代码块，其实它还可以修饰内部类，使用static修饰的内部类我们称之为静态内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着： 静态内部类的创建是不需要依赖于外围类，可以直接创建静态内部类不可以使用任何外围类的非static成员变量和方法，而内部类则都可以 成员内部类 成员内部类也是最普通的内部类，它是外部类的一个成员，所以他是可以无限制的访问外围类的所有成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。 在成员内部类中要注意两点： 成员内部类中不能存在任何static的变量和方法成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类 局部内部类 有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。 匿名内部类 匿名内部类其实就是一个没有名字的方法内部类，所以它符合方法内部类的所有约束，初次之外，还有一些地方需要注意： 匿名内部类是没有访问修饰符的。匿名内部类必须继承一个抽象类或者实现一个接口匿名内部类中不能存在任何静态成员或方法匿名内部类是没有构造方法的，因为它没有类名。一般使用匿名内部类的场景是，要继承或实现的接口只有一个抽象方法，比如添加一个监听器 特点为什么要使用内部类？在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。⒈ 内部类对象可以访问创建它的对象的实现，包括私有数据；⒉ 内部类不为同一包的其他类所见，具有很好的封装性；⒊ 使用内部类可以很方便的编写事件驱动程序；⒋ 匿名内部类可以方便的定义运行时回调；5.内部类可以方便的定义 匿名内部类匿名内部类的创建方式1234new 父类构造器（参数列表）|实现接口（） &#123; //匿名内部类的类体部分 &#125; 使用匿名内部类我们必须要继承一个父类或者实现一个接口,这是因为匿名内部类是直接使用new来生成一个对象的引用。当然这个引用是隐式的1234567891011public class Anonymous &#123; //测试匿名内部类 public static void main(String[] args) &#123; Inner inner = new Inner() &#123; @Override public String getName() &#123; return "tom"; &#125; &#125;; System.out.println(inner.getName()); 在使用匿名内部类的过程中，我们需要注意如下几点： 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。 匿名内部类中是不能定义构造函数的。 匿名内部类中不能存在任何的静态成员变量和静态方法。 匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java单例模式]]></title>
    <url>%2F2018%2F07%2F14%2Fjava%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式概述 单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例 Java中单例模式定义：“一个类有且仅有一个实例，并且自行实例化向整个系统提供。” 单例模式三要素： 私有的构造方法； 指向自己实例的私有静态引用； 以自己实例为返回值的静态的公有方法。 单例模式实现 单例模式可以分为懒汉式和饿汉式： 懒汉式单例模式：在类加载时不初始化。饿汉式单例模式：在类加载时就完成了初始化，所以类加载比较慢，但获取对象的速度快。 第一种（懒汉，线程不安全）12345678910public class SingletonDemo &#123; private static SingletonDemo instance; private SingletonDemo1()&#123;&#125; public static SingletonDemo1 getInstance()&#123; if (instance == null) &#123; instance = new SingletonDemo1(); &#125; return instance; &#125; &#125; 第二种（懒汉，线程安全）1234567891011public class SingletonDemo &#123; public class SingletonDemo &#123; private static SingletonDemo instance; private SingletonDemo2()&#123;&#125; public static synchronized SingletonDemo2 getInstance()&#123; if (instance == null) &#123; instance = new SingletonDemo2(); &#125; return instance; &#125; &#125; 第三种（饿汉）12345678public class SingletonDemo &#123; public class SingletonDemo &#123; private static SingletonDemo instance = new SingletonDemo3(); private SingletonDemo3()&#123;&#125; public static SingletonDemo3 getInstance()&#123; return instance; &#125; &#125; 单例模式优缺点 优点： 在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例 单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。 提供了对唯一实例的受控访问。 由于在系统内存中只存在一个对象，因此可以 节约系统资源，当 需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。 允许可变数目的实例。 避免对共享资源的多重占用。 缺点 不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。 由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。 单例类的职责过重，在一定程度上违背了“单一职责原则”。 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。使用场景由于单例模式具有以上优点，并且形式上比较简单，所以是日常开发中用的比较多的一种设计模式，其核心在于为整个系统提供一个唯一的实例，其应用场景包括但不仅限于以下几种： 有状态的工具类对象； 频繁访问数据库或文件的对象；我的cnds：https://blog.csdn.net/qq_38384971]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[text]]></title>
    <url>%2F2018%2F07%2F14%2Ftext%2F</url>
    <content type="text"><![CDATA[下载图片 点击加载下载文档点击下载 Think In Java在线 测试1测试2###测试3 ####测试4 代码测试public static void main(String[] args) { MyLinkList myLinkList = new MyLinkList(); for (int i = 0; i &lt; 100; i++) { myLinkList.add(i); } public static void main(String[] args) { MyLinkList myLinkList = new MyLinkList(); for (int i = 0; i &lt; 100; i++) { myLinkList.add(i);ll } 测试yLinkList.add(i); 序列测试 测试 cs 测试 测试 测试测试测试分页测试 代码类型测试12345public static void main(String[] args) &#123; MyLinkList myLinkList = new MyLinkList(); for (int i = 0; i &lt; 100; i++) &#123; myLinkList.add(i); &#125; [] [title] [url] [link text]123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*- # 定义函数def printme( str ): "打印任何传入的字符串" print str; return; # 调用函数printme("我要调用用户自定义函数!");printme("再次调用同一函数"); [] [title] [url] [link text]1234567var w=window.innerWidth|| document.documentElement.clientWidth|| document.body.clientWidth;var h=window.innerHeight|| document.documentElement.clientHeight|| document.body.clientHeight; [] [title] [url] [link text]12345678&lt;div id="bpn"&gt;&lt;ul class="prenext"&gt;&lt;li class="pre"&gt;&lt;a href="/js/js_obj_regexp.asp" title="JavaScript RegExp 对象"&gt;JS 正则表达式&lt;/a&gt;&lt;/li&gt;&lt;li class="next"&gt;&lt;a href="/js/js_window_screen.asp" title="JavaScript Window Screen"&gt;JS Screen&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt; [lang:] [title] [url] [link text]1 2018/7/14 16:55:56]]></content>
  </entry>
  <entry>
    <title><![CDATA[链表的java实现]]></title>
    <url>%2F2018%2F07%2F13%2F%E9%93%BE%E8%A1%A8%E7%9A%84java%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[创建一个节点和一个对象 节点包含两个属性：数据，和指向连接对象实现添加和查询方法 ##创建节点1234567891011121314151617181920212223public class Node &#123; private int date; private Node next; public int getDate() &#123; return date; &#125; public void setDate(int date) &#123; this.date = date; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node next) &#123; this.next = next; &#125; &#125; ##创建对象1234567891011121314151617181920212223242526272829public class MyLinkList &#123; private Node head=new Node(); private Node tail=head; //定义存放数据方法 public void add(int num)&#123; //创建一个节点，将数据填充到节点，将尾部节点指向新创建的节点 Node node=new Node(); //将数据填充节点 node.setDate(num); tail.setNext(node); tail=node; &#125; //定义get方法 public int get(int index)&#123; Node target=head; for (int i = 0; i &lt; index+1; i++) &#123; target=target.getNext(); &#125; return target.getDate(); &#125; public static void main(String[] args) &#123; MyLinkList myLinkList = new MyLinkList(); for (int i = 0; i &lt; 100; i++) &#123; myLinkList.add(i); &#125; System.out.println(myLinkList.get(1)); &#125; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
</search>
