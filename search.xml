<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql基础]]></title>
    <url>%2F2018%2F08%2F11%2Fmysql%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数据库概述数据库（Database）是按照数据结构来组织、存储和管理数据的仓库，每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。RDBMS即关系数据库管理系统(Relational Database Management System)的特点： 数据以表格的形式出现 每行为各种记录名称 每列为记录名称所对应的数据域 许多的行和列组成一张表单 若干的表单组成database 数据库分类关系型数据库（英语：Relational database），是创建在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。关系模型是由埃德加·科德于1970年首先提出的，并配合“科德十二定律”。现如今虽然对此模型有一些批评意见，但它还是数据存储的传统标准。标准数据查询语言SQL就是一种基于关系数据库的语言，这种语言执行对关系数据库中数据的检索和操作 MySQL MariaDB（MySQL的代替品，英文维基百科从MySQL转向MariaDB） Percona Server（MySQL的代替品） PostgreSQL Microsoft Access SQL Server Oracle非关系型数据库NoSQL一词最早出现于1998年，是Carlo Strozzi开发的一个轻量、开源、不提供SQL功能的关系数据库。当代典型的关系数据库在一些数据敏感的应用中表现了糟糕的性能，例如为巨量文档创建索引、高流量网站的网页服务，以及发送流式媒体。关系型数据库的典型实现主要被调整用于执行规模小而读写频繁，或者大批量极少写访问的事务。常用的：Key/value最终一致性存储Apache Cassandra（为Facebook所使用）：高度可扩展Key/value RAM存储RedismysqlMySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下公司。MySQL 最流行的关系型数据库管理系统，在 WEB 应用方面MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。MySQL安装下载mysql： http://dev.mysql.com/downloads/mysql/ 安装时，MySQL会提示输入root用户的口令，请务必记清楚。如果怕记不住，就把口令设置为password。在Windows上，安装时请选择UTF-8编码，以便正确地处理中文连接：mysql管理人默认为root，没有设置密码则直接登录mysql -h host -u root -p 输入密码按回车进入修改密码：update user set password=password(”2512″) where user=’root’;mysql操作基础操作分为两部分，数据库和表的创建，数据库和表的操作数据库和表的创建1.显示数据库SHOW DATABASES;2.创建数据库CREATE DATABASE 数据库名称;3.打开数据库use 数据库名称;每次使用数据库必须打开相应数据库4.显示当前使用的数据库中所有表SHOW TABLES;5.创建数据表1234567create table 表名( 列名 类型 是否可以为空， 列名 类型 是否可以为空); 6.示表mysql数据库中user表的列信息desc 表名;7.删除数据表drop table 表名8.清空表delete from 表名 数据库和表内容的操作(增、删、改、查)数据库主要操作 增关键字：insert into向数据库添加一行值insert into 表 (列名,列名...) values(值,值,值...)；向数据库添加一行值insert into 表 (列名,列名...) values(值,值,值...),(值,值,值...)；如果向表中的每个字段都插入一个值,那么前面括号内字段名可写也可不写insert into 表 values(值,值,值...),(值,值,值...) 删关键字：delect删除整个表中的信息delete from table_name;删除表中指定条件的语句delete from table_name where 条件语句 ; 条件语句如 : id=3; 改关键字：update更新指定数据 , 更新某一个字段的数据Update table_name set 字段名=’新值’ ; 查关键字：select 普通查询select * from 表;select * from 表 where 条件语句; 通配符(模糊查询 like)ale开头的所有（多个字符串）select * from 表 where name like &#39;ale%&#39;ale开头的所有（一个字符)select * from 表 where name like &#39;ale_&#39; 排序（order by）根据 “列” 从小到大排列select * from 表 order by 列 asc根据 “列” 从大到小排列select * from 表 order by 列 desc列1” 从大到小排列，如果相同则按列2从小到大排序select * from 表 order by 列1 desc,列2 asc 分组（group by）select count(*) from 表 group by 字段select count(*) from 表 group by 字段 having 条件语句当group by 与聚合函数配合使用时，功能为分组后计算having:作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组当group by 与having配合使用时，功能为分组后过滤MySQL的一些函数1、字符串链接——CONCAT() SELECT CONCAT(name,&#39;=&gt;&#39;,score) FROM tb_name 2、数学函数： AVG、SUM、MAX、MIN、COUNT；3、文本处理函数： TRIM、LOCATE、UPPER、LOWER、SUBSTRING4、运算符： +、-、*、\5、时间函数：DATE()、CURTIME()、DAY()、YEAR()、NOW()…..表结构修改1.增加一个字段 alter table table_name add column (字段名 字段类型); ----此方法带括号 2.指定字段插入的位置alter table table_name add column 字段名 字段类型 after 某字段；3.修改字段名称/类型alter table table_name change 旧字段名 新字段名 新字段的类型;4.改表的名字alter table table_name rename to new_table_name;增加主键，外键，约束，索引1.添加主键ALTER TABLE person ADD PRIMARY KEY (id);2.删除主键ALTER TABLE person DROP PRIMARY KEY;3.添加唯一索引ALTER TABLE person ADD UNIQUE name_unique_index (name);为name这一列创建了唯一索引,索引的名字是name_unique_index.4.添加普通索引ALTER TABLE person ADD INDEX birthday_index (birthday);5.删除索引12ALTER TABLE person DROP INDEX birthday_index;ALTER TABLE person DROP INDEX name_unique_index;]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2F2018%2F08%2F11%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射是框架设计的灵魂 想理解反射的原理，首先要了解什么是类型信息。Java让我们在运行时识别对象和类的信息，主要有2种方式：一种是传统的RTTI，它假定我们在编译时已经知道了所有的类型信息；另一种是反射机制，它允许我们在运行时发现和使用类的信息 概述JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.总结：反射就是把java类中的各种成分映射成一个个的Java对象 功能在运行时构造任意一个类的对象在运行时获取任意一个类所具有的成员变量和方法在运行时调用任意一个对象的方法（属性）生成动态代理 class类 Class是一个类，封装了当前对象所对应的类的信息 Class 是一个类; 一个描述类的类.封装了描述方法的 Method,描述字段的 Filed,描述构造器的 Constructor 等属性 对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个类的有关信息 Class 对象只能由系统建立对象，一个类（而不是一个对象）在 JVM 中只会有一个Class实例 获取Class对象的三种方式比如先建一个Person类123456789101112131415161718192021222324252627282930 package com.skyurb;public class Person &#123; private String id; private int age; public Person() &#123; &#125; public Person(String id, int age) &#123; this.id = id; this.age = age; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 通过类名获取 类名.class 通过对象获取 对象名.getClass() 通过全类名获取 Class.forName(全类名) 1234567//1.通过类名.class获取 类 Class clazz = Person.class; //2.通过对象getclass也可以获取对象所属类 Person tom = new Person("tom", 5); Class&lt;? extends Person&gt; clazz1 = tom.getClass(); //3.通过Class的静态方法获取 Class&lt;?&gt; clazz3 = Class.forName("com.skyurb.Person"); class类常用方法我们可以通过反射来获取类的信息 方法名 功能 static Class forName(String name) 返回指定类名 name 的 Class 对象 Object newInstance() 调用缺省构造函数，返回该Class对象的一个实例 getName() 返回此Class对象所表示的实体（类、接口、数组类、基本类型或void）名称 Class getSuperClass() 返回当前Class对象的父类的Class对象 Class [] getInterfaces() 获取当前Class对象的接口 ClassLoader getClassLoader() 返回该类的类加载器 Class getSuperclass() 返回该类的类加载器 实例：1234567Class&lt;Person&gt; clazz = Person.class; //结果：com.skyurb.Person System.out.println(clazz.getName()); //利用Class对象的newInstance方法创建一个类的实例 Person person = clazz.newInstance(); System.out.println(person); //结果：com.skyurb.Person@14ae5a5 可以看出确实是创建了一个Person实例但是Person类有两个构造方法，到底是调用的哪一个构造方法呢实际调用的是类的无参数的构造器。所以在我们在定义一个类的时候，定义一个有参数的构造器，作用是对属性进行初始化，还要写一个无参数的构造器，作用就是反射时候用。一般地、一个类若声明一个带参的构造器，同时要声明一个无参数的构造器创建带参的实例这时要通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。123//创建带参的对象 Constructor&lt;Person&gt; constructor = clazz.getConstructor(String.class, int.class); Person person1 = constructor.newInstance("小明", 15); 反射方式获取字段(成员变量)主要是这几个方法： getFields: 访问公有的成员变量 getDeclaredFields：所有已声明的成员变量。但不能得到其父类的成员变量12345Field[] fields = clazz.getDeclaredFields(); for (Field f : fields) &#123; System.out.println(f.getName()); &#125; //结果id age 反射方式获取方法获取某个Class对象的方法集合，主要有以下几个方法： getDeclaredMethods() 方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 getMethods() 方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。 getMethod方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象 1234567891011Method[] methods = clazz.getDeclaredMethods(); for (Method m : methods) &#123; //获取返回值类型 m.getReturnType(); System.out.println(m.getName()); &#125; //结果getId //getAge //setAge //setId 使用调用方法例如我们通过反射来设置id属性1234Person instance = (Person) clazz.newInstance();Method setId = clazz.getMethod("setId", String.class);//调用setid方法，第一个class表示方法所属对象 第二个object表示方法参数setId.invoke(person,"jack"); clazz.getMethod(methodName, argsClass)：通过methodName和参数的argsClass（方法中的参数类型集合）数组得到要执行的Method。method.invoke(owner, args)执行该Method.invoke方法的参数是执行这个方法的对象owner，和参数数组args可以这么理解：owner对象中带有参数args的method方法。返回值是Object，也既是该方法的返回值 通过反射越过泛型检查泛型用在编译期，编译过后泛型擦除（消失掉）。所以是可以通过反射越过泛型检查的123456789101112131415161718public static void main(String[] args) throws Exception&#123; ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add("aaa"); strList.add("bbb"); // strList.add(100); //获取ArrayList的Class对象，反向的调用add()方法，添加数据 Class listClass = strList.getClass(); //得到 strList 对象的字节码 对象 //获取add()方法 Method m = listClass.getMethod("add", Object.class); //调用add()方法 m.invoke(strList, 100); //遍历集合 for(Object obj : strList)&#123; System.out.println(obj); &#125;&#125; 参考自：https://www.cnblogs.com/tech-bird/p/3525336.html]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习二]]></title>
    <url>%2F2018%2F08%2F04%2Fgit%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[分支管理在版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 创建与合并分支首先，我们来创建dev分支，然后切换到dev分支上git checkout -b devgit checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令git branch devgit checkout dev查看当前分支123 git branch* devmaster git branch查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在dev分支上继续做demo，比如我们现在在read.txt再增加一行good,添加后并提交1234 cat read.txthelloworldgood 现在我们切换到主分支master上，继续查看read.txt内容123cat read.txthelloworld 发现good没有了现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令 git merge devgit merge命令用于合并指定分支到当前分支上，合并后，再查看read.txt内容，可以看到，和dev分支最新提交的是完全一样的。意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。合并完成后，我们可以接着删除dev分支了，操作如下：12git branch -d devDeleted branch dev (was 8df4ce8). 总结创建与合并分支命令 查看分支：git branch 创建分支：git branch name 切换分支：git checkout name 创建+切换分支：git checkout –b name 合并某分支到当前分支：git merge name 删除分支：git branch –d name 解决冲突先新建一个新分支，比如名字叫fenzhi1，在read.txt添加一行内容byby，然后提交我们现在切换到master分支上来，也在最后一行添加内容，内容为byby现在我们需要在master分支上来合并fenzhi1：12345 $ git merge fenzhi1 //结果Auto-merging read.txt (content): Merge conflict in read.txtAutomatic merge failed; fix conflicts and then commit the result. Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容1234567891011 cat read.txt&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADhello world;baby=======hello wordhahhahai am jacklet's go;babay&gt;&gt;&gt;&gt;&gt;&gt;&gt; fenzhi1 我们可以修改下和主干一样后保存。 分支管理策略通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。首先我们来做demo演示下： 创建一个dev分支。 修改readme.txt内容。 添加到暂存区。 切换回主分支(master)。 合并dev分支，使用命令 git merge –no-ff -m “注释” dev 查看历史记录 分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础笔记整理一]]></title>
    <url>%2F2018%2F08%2F03%2Fjava%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Comparator和Comparable接口的区别java中，对集合对象或者数组对象排序，有两种实现方式。 对象实现Comparable 接口 定义比较器，实现Comparator接口ComparableComparable可以认为是一个内比较器，实现了Comparable接口的类有一个特点，就是这些类是可以和自己比较的，至于具体和另一个实现了Comparable接口的类如何比较，则依赖compareTo方法的实现，compareTo方法也被称为自然比较方法。如果开发者add进入一个Collection的对象想要Collections的sort方法帮你自动进行排序的话，那么这个对象必须实现Comparable接口。compareTo方法的返回值是int，有三种情况：1、比较者大于被比较者（也就是compareTo方法里面的对象），那么返回正整数2、比较者等于被比较者，那么返回03、比较者小于被比较者，那么返回负整数 ComparatorComparator可以认为是是一个外比较器，个人认为有两种情况可以使用实现Comparator接口的方式：1、一个对象不支持自己和自己比较（没有实现Comparable接口），但是又想对两个对象进行比较2、一个对象实现了Comparable接口，但是开发者认为compareTo方法中的比较方式并不是自己想要的那种比较方式Comparator接口里面有一个compare方法，方法有两个参数T o1和T o2，是泛型的表示方式，分别表示待比较的两个对象，方法返回值和Comparable接口一样是int，有三种情况：1、o1大于o2，返回正整数2、o1等于o2，返回03、o1小于o3，返回负整数 在使用hashmap时为何要重写key的hashcode和equals方法 Java中的超类Object类中定义的equals()方法是用来比较两个引用所指向的对象的内存地址是否一致重点要注意的是： 在java应用程序运行时，无论何时多次调用同一个对象时的hsahCode()方法，这个对象的hashCode()方法的返回值必须是相同的一个int值 如果两个对象equals()返回值为true,则他们的hashCode()也必须返回相同的int值 如果两个对象equals()返回值为false,则他们的hashCode()返回值也必须不同我们在定义类时，我们经常会希望两个不同对象的某些属性值相同时就认为他们相同，所以我们要重写equals()方法，按照原则，我们重写了equals()方法，也要重写hashCode()方法 装饰模式装饰(Decorator)模式又名包装(Wrapper)模式。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。 装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式使用原来被装饰的类的一个子类的实例，把客户端的调用委派到被装饰类。关键在于这种扩展是完全透明的。与生成子类相比，它更具有灵活性。在装饰模式中的各个角色有： 抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附件责任的对象。具体构件（Concrete Component）角色：定义一个要接收附加责任的类。装饰（Decorator）角色：持有一个构件（Component）对象的实例，并定义一个与抽象构件接口一致的接口。具体装饰（Concrete Decorator）角色：负责给构件对象“贴上”附加的责任。 Component为组件和装饰的公共父类，它定义了子类必须实现的方法。 ConcreteComponent是一个具体的组件类，可以通过给它添加装饰来增加新的功能。 Decorator是所有装饰的公共父类，它定义了所有装饰必须实现的方法，同时，它还保存了一个对于Component的引用，以便将用户的请求转发给Component，并可能在转发请求前后执行一些附加的动作。 ConcreteDecorator1和ConcreteDecorator2是具体的装饰，可以使用它们来装饰具体的Component。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[40个多线程问题总结]]></title>
    <url>%2F2018%2F07%2F30%2F40%E4%B8%AA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[多线程有什么用？ 发挥多核CPU的优势 随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。 防止阻塞 从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。 便于建模 这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。 创建线程的方式比较常见的一个问题了，一般就是两种： 继承Thread类 实现Runnable接口 至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。 start()方法和run()方法的区别只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。 Runnable接口和Callable接口的区别有点深的问题了，也看出一个Java程序员学习知识的广度。 Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。 这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。 CyclicBarrier和CountDownLatch的区别两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于： CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行 CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务 CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了 Volatile关键字的作用一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个： 多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据 代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率 从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。 什么是线程安全又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。 这个问题有值得一提的地方，就是线程安全也是有几个级别的： 不可变 像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用 绝对线程安全 不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet 相对线程安全 相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。 线程非安全 这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类 Java中如何获取到线程dump文件死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步： 获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java 打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid 另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈， 一个线程如果出现了运行时异常会怎么样如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放 如何在两个线程之间共享数据通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的 sleep方法和wait方法有什么区别这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器 生产者消费者模型的作用是什么这个问题很理论，但是很重要： 通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用 解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约 ThreadLocal有什么用简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了 为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁 wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。 为什么要使用线程池避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。 怎么检测一个线程是否持有对象监视器我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着“某条线程”指的是当前线程。 synchronized和ReentrantLock的区别synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 ReentrantLock可以获取各种锁的信息 ReentrantLock可以灵活地实现多路通知 另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。 ConcurrentHashMap的并发度是什么ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？ ReadWriteLock是什么首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。 因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。 FutureTask是什么这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。 Linux环境下如何查找哪个线程使用CPU最长这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做： （1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过 （2）top -H -p pid，顺序不能改变 这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。 使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。 最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。 Java编程写一个会导致死锁的程序第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。 真正理解什么是死锁，这个问题其实不难，几个步骤： （1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁； （2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁 （3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的 这样，线程1″睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，Java多线程7：死锁这篇文章里面有，就是上面步骤的代码实现。 怎么唤醒一个阻塞的线程如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。 不可变对象对多线程有什么帮助前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。 什么是多线程的上下文切换多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。 如果你提交任务时，线程池队列已满，这时会发生什么如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务；如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。 Java中用到的线程调度算法是什么抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。 Thread.sleep(0)的作用是什么这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。 什么是自旋很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行地非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。 什么是Java内存模型Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容： Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去 定义了几个原子操作，用于操作主内存和工作内存中的变量 定义了volatile变量的使用规则 （4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的 什么是CASCAS，全称为Compare and Set，即比较-设置。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。 什么是乐观锁和悲观锁 乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-设置这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。 悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。 什么是AQS简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。 如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。 AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。 单例模式的线程安全性老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下： 饿汉式单例模式的写法：线程安全 懒汉式单例模式的写法：非线程安全 双检锁单例模式的写法：线程安全 Semaphore有什么作用Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。 Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？ 关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点： 同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性 CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成汇编代码执行的，汇编代码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句”return count”假设被翻译成了三句汇编语句执行，完全可能执行完第一句，线程就切换了。 线程类的构造方法、静态块是被哪个线程调用的这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。 如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么： （1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的 （2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的 同步方法和同步块，哪个是更好的选择同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越少越好。 借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。 高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换 （2）并发不高、任务执行时间长的业务要区分开看： a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务 b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换 （3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。 转载自： https://www.cnblogs.com/xrq730/p/5060921.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[java基础练习题]]></title>
    <url>%2F2018%2F07%2F25%2Fjava%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.字符串排序1234567891011121314151617181920public static void main(String[] args) &#123; //给定一字符串，进行排序 String str = "hello"; char[] chars = str.toCharArray(); char temp=' '; for (int i = 0; i &lt; chars.length; i++) &#123; for (int j = 0; j &lt;i ; j++) &#123; if (chars[i]&lt;chars[j])&#123; temp=chars[i]; chars[i]=chars[j]; chars[j]=temp; &#125; &#125; &#125; //第二种方法，利用工具类 Arrays.sort(chars); System.out.println(chars); &#125; 字符串，将其首字母转为大写，后续字母转为小写输出。1234567public static void main(String[] args) &#123; //给定任意字符串，将其首字母转为大写，后续字母转为小写输出。 String str="helLOBaby"; String s1 = str.substring(0, 1).toUpperCase(); String s2 = str.substring(1).toLowerCase(); System.out.println(s1+s2); &#125; 彩票问题 有一个股票价格序列共10天。每天的价格是{4，2，1，3，5，7，5，7，8，8}。规定：3日移动平均价格大于当天价格则买入。请问第一次出现买入信号是第几天，总共出现几次买入信号。提示：3日移动平均是指当前以及以后两天的价格的平均值。 1234567891011121314151617public static void main(String[] args) &#123; int arry[]=&#123;4,2,1,3,5,7,5,7,8,8&#125;; int days=0; int count=0; for (int i = 0; i &lt; arry.length-2; i++) &#123; double avg=(arry[i]+arry[i+1]+arry[i+2])/3.0; if (arry[i]&lt;avg)&#123; count++; if (count==1)&#123; System.out.println("第"+(i+1)+"天"); &#125; &#125; &#125; System.out.println("一共出现五次"+count); &#125; 用蒙特卡洛模拟求出圆周率12345678910111213141516171819202122232425static double MontePI(int n) &#123; double PI; double x, y; int i, sum; sum = 0; for (i = 1; i &lt; n; i++) &#123; x = Math.random(); y = Math.random(); if ((x * x + y * y) &lt;= 1) &#123; sum++; &#125; &#125; PI = 4.0 * sum / n; return PI; &#125; public static void main(String[] args) &#123; int n; double PI; System.out.println("蒙特卡洛概率算法计算圆周率:"); Scanner input = new Scanner(System.in); System.out.println("输入点的数量："); n = input.nextInt(); PI = MontePI(n); System.out.println("PI="+PI); &#125; 求出字符不同字母的个数123456789101112public static void main(String[] args) &#123; //求出字符不同字母的个数 String str=""; String str3="hello"; for (int i = 0; i &lt; str3.length(); i++) &#123; String ch=str3.substring(i,i+1); if (!str.contains(ch))&#123; str+=ch; &#125; &#125; System.out.println(str.length()); &#125; 判断字符串是否对称123456789101112131415161718192021public static void main(String[] args) &#123; //判断字符串是否对称 boolean flag = false; Scanner s = new Scanner(System.in); System.out.println("请输入一个字符串"); String str = s.next(); char ch[] = str.toCharArray(); for (int i = 0; i &lt; ch.length / 2; i++) &#123; if (ch[i] != ch[ch.length - i - 1]) &#123; flag = false; break; &#125; else &#123; continue; &#125; &#125; if (flag) &#123; System.out.println("yes"); &#125; else &#123; System.out.println("no"); &#125; &#125; 创建一个可以无限存放数组的容器123456789101112131415161718192021222324252627282930313233343536public class MyArryList &#123; //创建一个可以无限存放数组的容器 private int size=16; private int[] init=new int[size]; private int index=0; //从集合中取 public int get(int index)&#123; if (index&lt;0)&#123; System.out.println("下标不能小于0"); return -1; &#125; return init[index]; &#125; public void add(int num)&#123; if (index&gt;size*0.75)&#123; size*=2; //创建两倍大小数组 int []newArry=new int[size]; //遍历老数组,复制到新数组中 for (int i = 0; i &lt; init.length; i++) &#123; newArry[i]=init[i]; &#125; init=newArry; &#125; init[index]=num; index++; &#125; public static void main(String[] args) &#123; MyArryList myArryList = new MyArryList(); for (int i = 0; i &lt;200 ; i++) &#123; myArryList.add(i); &#125; System.out.println(myArryList.get(18)); &#125; 链表的实现原理12345678910111213141516171819202122public class Node &#123; //存放数据 private int date; //指向下一个节点个引用 private Node next; public int getDate() &#123; return date; &#125; public void setDate(int date) &#123; this.date = date; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node next) &#123; this.next = next; &#125;&#125; 1234567891011121314151617181920212223242526272829303132public class MyLinkList &#123; private Node head=new Node(); private Node tail=head; //定义存放数据方法 public void add(int num)&#123; //创建一个节点，将数据填充到节点，将尾部节点指向新创建的节点 Node node=new Node(); //将数据填充节点 node.setDate(num); //然后将 // Node next=tail.getNext(); tail.setNext(node); tail=node; &#125; //定义get方法 public int get(int index)&#123; Node target=head; for (int i = 0; i &lt; index+1; i++) &#123; target=target.getNext(); &#125; return target.getDate(); &#125; public static void main(String[] args) &#123; MyLinkList myLinkList = new MyLinkList(); for (int i = 0; i &lt; 100; i++) &#123; myLinkList.add(i); &#125; System.out.println(myLinkList.get(5)); &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习]]></title>
    <url>%2F2018%2F07%2F23%2Fgit%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[简介 Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 安装Git 目前支持 Linux/Unix、Solaris、Mac和 Windows 平台上运行。Git 各平台安装包下载地址为：http://git-scm.com/downloads liunx（Debian/Ubuntu）下下载：12apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \libz-dev libssl-dev liunx（Centos/RedHat）12apt-get install gityum -y install git-core 配置 配置个人的用户名称和电子邮件地址： 12git config --global user.name "yourname"git config --global user.email youremail@runoob.com 查看配置信息 1git config --list 检查版本 1git --version 使用创建版本库什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。 首先创建一个目录（比如在e盘创建一个目录gittest） 12cd e:mkdir gittest 通过命令 git init 把这个目录变成git可以管理的仓库 12cd gittestgit init 这时候你当前gittest目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了. 把文件添加到版本库中首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道-使用命令 git add read.txt添加到暂存区里面去12touch read.txtgit add read.txt 没有任何提示，说明已经添加成功了-用命令 git commit告诉Git，把文件提交到仓库1234git commit -m 'read.txt提交'[master (root-commit) ba2c0c8] read.txt提交1 file changed, 0 insertions(+), 0 deletions(-)create mode 100644 read.txt git commit后面跟的是提交的注释我们可以通过命令git status来查看是否还有文件未提交1234git status//结果On branch masternothing to commit, working tree clean 说明没有任何文件未提交，但是我现在继续来改下read.txt内容，比如我在下面添加一行hello内容，继续使用git status来查看下结果1234567891011vi read.txt//在vi编辑器插入hellogit status//结果如下On branch masterChanges not staged for commit:(use "git add &lt;file&gt;..." to update what will be committed)(use "git checkout -- &lt;file&gt;..." to discard changes in working directory)modified: read.txtno changes added to commit (use "git add" and/or "git commit -a") 上面的命令告诉我们 reae.txt文件已被修改，但是未被提交的修改。想看下read.txt文件到底改了什么内容可以用git diff read.txt12345678910 git diff read.txt //结果如下warning: LF will be replaced by CRLF in read.txt.The file will have its original line endings in your working directory.diff --git a/read.txt b/read.txtindex e69de29..ce01362 100644--- a/read.txt+++ b/read.txt@@ -0,0 +1 @@+hello 可以看到，read.txt文件内容从没有改成一行添加了一行hello内容知道了对read.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是git add 第二步是：git commit)1234 git commit -m 'read.txt提交增加hello'//结果[master f4dd0e7] read.txt提交增加hello 1 file changed, 1 insertion(+) 版本回退现在我继续对readme.txt文件进行修改，再增加一行world1234 git commit -m 'read.txt提交增加world'//结果[master f4dd0e7] read.txt提交增加world 1 file changed, 1 insertion(+) 现在我已经对read.txt文件做了三次修改了，那么我现在想查看下历史记录，可以使用命令 git log ：12345678910111213141516171819 git log//结果commit 64a95f6216fa491fcd0517764c18168c5db0725e (HEAD -&gt; master)Author: skyurb &lt;2864814961@qq.com&gt;Date: Sat Aug 4 11:37:26 2018 +0800 read.txt提交增加worldcommit f4dd0e7e782c60948526fafbf1283c57c435b95dAuthor: skyurb &lt;2864814961@qq.com&gt;Date: Sat Aug 4 11:34:34 2018 +0800 read.txt提交增加hellocommit ba2c0c83e1930b0a16125d10ebed7fee2ce6ba02Author: skyurb &lt;2864814961@qq.com&gt;Date: Sat Aug 4 11:19:45 2018 +0800 read.txt提交 git log命令显示从最近到最远的显示日志，我们可以看到最近三次提交记录，如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset --hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset --hard HEAD~100 即可123456 git reset - -hard HEAD^ //结果 HEAD is now at f4dd0e7 read.txt提交增加hellocat read.txt //结果hello 我们再用cat查看就只剩hello了，增加的world内容我们看不到了，但是现在我想回退到最新的版本，如：有world的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：git reset --hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加world内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog 演示如下：123456git reflog //结果f4dd0e7 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD^64a95f6 HEAD@&#123;1&#125;: commit: read.txt提交增加worldf4dd0e7 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: read.txt提交增加helloba2c0c8 HEAD@&#123;3&#125;: commit (initial): read.txt提交 通过上面的显示我们可以知道，增加内容world的版本号是 64a95f6.我们现在可以命令git reset –hard 64a95f6来恢复了12git reset --hard 64a95f6HEAD is now at 64a95f6 read.txt提交增加world 这时，又恢复到原来有world的版本 理解工作区与暂存区的区别 工作区：就是你在电脑上看到的目录，比如目录下gittest里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。 版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。我们前面说过使用Git提交文件到版本库有两步： 是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。 使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。Git撤销修改和删除文件操作如果我又在read.txt文件里面加一行 good morning，但在未提交之前发现提交的内容有误，所以我要马上恢复以前的版本，现在有两种方法： 如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。 我可以按以前的方法直接恢复到上一个版本。使用 git reset –hard HEAD^但是现在我不想使用上面的2种方法，我想直接想使用撤销命令该如何操作呢？首先在做撤销之前，我们可以先用 git status 查看下当前的状态。 12345678910 git status//结果On branch masterChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: read.txtno changes added to commit (use "git add" and/or "git commit -a") 可以发现，Git会告诉你，git checkout – file 可以丢弃工作区的修改1234git checkout -- read.txtcat read.txthelloworld 发现后面的内容就没有了，命令 git checkout – read.txt 意思就是，把read.txt文件在工作区做的修改全部撤销，这里有2种情况 read.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。 另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。注意：命令git checkout – readme.txt 中的 – 很重要，如果没有 – 的话，那么命令变成创建分支了。 删除文件假如我现在版本库gittest目录添加一个文件book.txt,然后提交12345678910 git status //结果 On branch master Changes not staged for commit: (use "git add/rm &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) deleted: book.txtno changes added to commit (use "git add" and/or "git commit -a") 一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm book.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉。只要没有commit之前，如果我想在版本库中恢复此文件。可以使用如下命令 git checkout -- book.txt1git checkout -- book.txt 这样被删掉的文件就能恢复了 远程仓库 先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置。创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：ssh-keygen -t rsa –C “youremail@example.com”, id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人 登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。点击 Add Key，你就应该可以看到已经添加的key 如何添加远程库现在的情景是：我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作 首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库 在Repository name填入你的仓库名，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库 目前，在GitHub上的这个testgit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库12345678910111213 git remote add origin https://github.com/skyurb/gittest.git //然后执行 git push -u origin master //结果Enumerating objects: 11, done.Counting objects: 100% (11/11), done.Delta compression using up to 4 threads.Compressing objects: 100% (5/5), done.Writing objects: 100% (11/11), 934 bytes | 934.00 KiB/s, done.Total 11 (delta 0), reused 0 (delta 0)To https://github.com/skyurb/gittest.git * [new branch] master -&gt; masterBranch 'master' set up to track remote branch 'master' from 'origin'. 把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了从现在起，只要本地作了提交，就可以通过如下命令： git push origin master把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了 如何从远程库克隆假如远程库有新的内容了，我想克隆到本地来 如何克隆使用命令git clone克隆一个本地库12345git clone https://github.com/skyurb/gittestCloning into 'gitskills'...remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3Receiving objects: 100% (3/3), done 就可以再本地看了 参考自廖雪峰官网 ：https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用HashMap实现简单的倒排索引]]></title>
    <url>%2F2018%2F07%2F20%2F%E7%94%A8HashMap%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[简述搜索引擎通常检索的场景是：给定几个关键词，找出包含关键词的文档用HashMap实现倒排索引的设想： 举例 有三本书，每本书中都会有几个关键字，通过关键字来检索到出现在那几本书中 实行：创建两个hashmap，一个用来存放原数据，一个用来存放新索引，以原数据的value分割后的单词做新索引的key，以原数据的value对应的key做索引value，添加到新索引中 实现 123456789101112131415161718192021222324252627282930313233343536373839public static void main(String[] args) &#123; //存储数据map HashMap date = new HashMap(); date.put("book1","hello world"); date.put("book2","hello beautiful world"); date.put("book3","hello beautiful new world"); //索引的map HashMap index = new HashMap(); Set keySet = date.keySet(); //遍历date的key for (Object word:keySet) &#123; String keyString = (String) word; //通过key获得value String count = (String) date.get(keyString); //将字符串分割成数组 String[] words = count.split(" "); //遍历数组，获取关键字 for (int i = 0; i &lt;words.length ; i++) &#123; //判断索引中是否存在关键字，如果不存在添加，存在将追加 if (!index.containsKey(words[i]))&#123; //创建一个arrylist用来添加或后续追加索引值 ArrayList books = new ArrayList(); //将date的key存入 books.add(keyString); //将新组建的键值对存入索引 index.put(words[i],books); &#125; else &#123; //如果存在关键字,通过关键字获取value， List books = (List) index.get(words[i]); //将date的key追加到value中 books.add(keyString); &#125; &#125; &#125; //输出新map System.out.println(index); &#125; 输出结果 123&#123;beautiful=[book2, book3], new=[book3], world=[book2, book1, book3], hello=[book2, book1, book3]&#125;Process finished with exit code 0]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础笔记整理]]></title>
    <url>%2F2018%2F07%2F19%2Fjava%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[java基础易错知识整理数组初始值下面代码输出结果是0 1234public static void main(String[] args) &#123; int[] arry=new int[10]; Sysout.out.println(arr[i]); &#125; –int类型：0 –short类型：(short）0 –byte类型：(byte）0 –long类型：0L –doulbe类型：0.0d –float类型：0.0f –char类型：\u0000（空格字符） –boolean类型：false–引用类型的数组在创建之后，赋默认值null，初始化后，int型默认值为0 throw和throws的区别抛出异常有三种形式，一是throw,一个throws，还有一种系统自动抛异常。下面它们之间的异同 当程序语句出现一些逻辑错误、主义错误或类型转换错误时，系统会自动抛出异常 123456 public static void main(String[] args) &#123; int a = 5, b =0; System.out.println(5/b); //function(); &#125; throw是语句抛出一个异常，一般是在代码块的内部，当程序出现某种逻辑错误时由程序员主动抛出某种特定类型的异常 12345678910public static void main(String[] args) &#123; String s = "abc"; if(s.equals("abc")) &#123; throw new NumberFormatException(); &#125; else &#123; System.out.println(s); &#125; &#125; throws是方法可能抛出异常的声明。(用在声明方法时，表示该方法可能要抛出异常) public void function() throws Exception{……} 当某个方法可能会抛出某种异常时用于throws 声明可能抛出的异常，然后交给上层调用它的方法程序处理 123456789101112131415 public class testThrows()&#123;public static void function() throws NumberFormatException&#123; String s = "abc"; System.out.println(Double.parseDouble(s)); &#125; public static void main(String[] args) &#123; try &#123; function(); &#125; catch (NumberFormatException e) &#123; System.err.println("非数据类型不能强制类型转换。"); //e.printStackTrace(); &#125; &#125; throw与throws的比较1、throws出现在方法函数头；而throw出现在函数体。2、throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。3、两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。参考自 ：https://blog.csdn.net/hjfcgt123/article/details/53349275 堆溢出和栈溢出 栈溢出(StackOverflowError) 堆溢出(OutOfMemoryError:java heap space)先了解一下java中的堆和栈，JAVA在程序运行时，在内存中划分5片空间进行数据的存储。分别是：1：寄存器。2：本地方法区。3：方法区。4：栈。5：堆。 基本数据类型、局部变量都是存放在栈内存中的，用完就消失。new创建的实例化对象及数组，是存放在堆内存中的，用完之后靠垃圾回收机制不定期自动消除。举个例子ArrayList list = new ArrayList(); 实际上，在创建完上面的一个对象后，在JVM中，会把new出来的对象存放在堆内存中， 同时，在方法栈中存放着对象的引用关系。 如果想要堆溢出，比较简单，可以循环创建对象或大的对象；死循环创建字符串对象或字符串拼接。 123456789101112131415public static void main(String[] args) &#123; ArrayList list=new ArrayList(); while(true) &#123; list.add(new Heap()); &#125; &#125; 如果想要栈溢出，可以递归调用方法，这样随着栈深度的增加，JVM 维持着一条长长的方法调用轨迹，直到内存不够分配，产生栈溢出。123456789101112131415public static void main(String[] args) &#123; new Stack().test(); &#125; public void test() &#123; test(); &#125; String和StringBuffer，StringBuilder区别这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面 首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; StringString最慢的原因： **String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。**12345public static void main(String[] args) &#123; String str="abc"; System.out.println(str); str=str+"de"; System.out.println(str); 如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。 而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多123456public static void main(String[] args) &#123; String str="abc"+"de"; StringBuilder stringBuilder=new StringBuilder().append("abc").append("de"); System.out.println(str); System.out.println(stringBuilder.toString()); &#125;这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多 在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的 如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。来自：https://www.cnblogs.com/su-feng/p/6659064.html Java中==号与equals()方法的区别 首先==号在比较基本数据类型时比较的是值，而用==号比较两个对象时比较的是两个对象的地址值：12345678public static void main(String[] args) &#123; int x = 10; int y = 10; String str1 = new String("abc"); String str2 = new String("abc"); System.out.println(x == y); // 输出true System.out.println(str1 == str2); // 输出false &#125; Equals是object中的方法，用于判断两个对象是否想等。默认的equals是== ,不过子类可以重写父类的方法，加以改变。典型如string integer等类都重写了equals方法ArrayList和LinkedList的区别 一个是Array(动态数组)的数据结构，一个是Link(链表)的数据结构，此外，它们两个都是对List接口的实现。前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列 当随机访问List时（get和set操作），ArrayList比LinkedList的效率更高，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找 当对数据进行增加和删除的操作时(add和remove操作)，LinkedList比ArrayList的效率更高，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动 从利用效率来看，ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。 ArrayList主要控件开销在于需要在List列表预留一定空间；而LinkList主要控件开销在于需要存储结点信息以及结点指针信息。来自于：https://www.cnblogs.com/Amedeo/p/7885146.html运行时异常和受检时异常区别最本质的区别是RuntimeException是运行时才会发生的异常, 而受检查异常是编译时异常,编译器会分析哪些异常会在执行一个方法或者构造函数的时候抛出。 运行时异常（RuntimeException）也称作未检测的异常（unchecked exception），这表示这种异常不需要编译器来检测。RuntimeException是所有可以在运行时抛出的异常的父类。一个方法除要捕获异常外，如果它执行的时候可能会抛出RuntimeException的子类，那么它就不需要用throw语句来声明抛出的异常 受检查异常（checked exception）都是编译器在编译时进行校验的，通过throws语句或者try{}cathch{} 语句块来处理检测异常。编译器会分析哪些异常会在执行一个方法或者构造函数的时候抛出。待续………]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符编码]]></title>
    <url>%2F2018%2F07%2F18%2F%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[常用字符编码分类 字符集编码：就是用数字来表示各种字符 asc码：美国国家标准码一个字节表示一个字符 UTF：unicode世界范围的统一编码用四个字节表示一个字符UTF-8:优化以后的utf码。让英文语系的编码量明显减少，有保证了世界范围的通用 GBK：汉字内码扩展规范 Big5：在台湾、香港与澳门地区，使用的是繁体中文字符集 总结 1、编码界最初只有ASCII码，只用了1byte中的7bit（0~127）； 2、欧洲人发现128个不够了，就把1byte中没用的最高位给用上了，出现了Latin系列（ISO-8859系列）编码； 3、中国人民通过对ASCII编码进行中文扩充改造，产生了GB2312编码，可以表示6000多个常用汉字； 4、汉字实在太多了，还有繁体、各种字符呀，于是加以扩展，有了GBK； 5、GBK还不够，少数民族的字还木有呀，于是GBK又扩展为GB18030； 6、每个国家、语言都有自己的编码，彼此无法交流，迫切需要大一统局面的出现； 7、Unicode诞生，可以容纳全世界的任何文字。Unicode分为UCS-2和UCS-4，分别是2字节和4字节，实际2字节就够用了； 8、为了Unicode能实际应用（存储、传输），制定了Unicode的编码方式，即UTF，有UTF-8、UTF-16、UTF-32，其中UTF-8应用广泛； 9、UTF-16、UTF-32均是多字节传输，存在字节顺序的问题，于是有了大头还是小头的概念，为了解决这个问题，引入了BOM。UTF-8是单字节传输，不存在这个问题，也就不需要BOM，但可以有，仅用来表明编码格式； 10、要从“环境/终端/文本/程序”等不同层次去理解编码，并尝试解决遇到的问题； 在线编码转换工具http://tool.chinaz.com/Tools/Unicode.aspx]]></content>
  </entry>
  <entry>
    <title><![CDATA[内部类]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[#定义：在一个类的内部又定义了一个类，这就是内部类。#举例：12345678public class OuterClass &#123; private String outerName; private int outerAge; public class InnerClass&#123; private String innerName; private int innerAge; &#125; &#125; 内部类是一个编译时概念，编译后外部类及其内部类会生成两个独立的class文件： OuterClass.class和OuterClass$InnerClass.class内部类可以直接访问外部类的元素，但是外部类不可以直接访问内部类的元素 表现形式 静态内部类 关键字static可以修饰成员变量、方法、代码块，其实它还可以修饰内部类，使用static修饰的内部类我们称之为静态内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着： 静态内部类的创建是不需要依赖于外围类，可以直接创建静态内部类不可以使用任何外围类的非static成员变量和方法，而内部类则都可以 成员内部类 成员内部类也是最普通的内部类，它是外部类的一个成员，所以他是可以无限制的访问外围类的所有成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。 在成员内部类中要注意两点： 成员内部类中不能存在任何static的变量和方法成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类 局部内部类 有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。 匿名内部类 匿名内部类其实就是一个没有名字的方法内部类，所以它符合方法内部类的所有约束，初次之外，还有一些地方需要注意： 匿名内部类是没有访问修饰符的。匿名内部类必须继承一个抽象类或者实现一个接口匿名内部类中不能存在任何静态成员或方法匿名内部类是没有构造方法的，因为它没有类名。一般使用匿名内部类的场景是，要继承或实现的接口只有一个抽象方法，比如添加一个监听器 特点为什么要使用内部类？在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。⒈ 内部类对象可以访问创建它的对象的实现，包括私有数据；⒉ 内部类不为同一包的其他类所见，具有很好的封装性；⒊ 使用内部类可以很方便的编写事件驱动程序；⒋ 匿名内部类可以方便的定义运行时回调；5.内部类可以方便的定义 匿名内部类匿名内部类的创建方式1234new 父类构造器（参数列表）|实现接口（） &#123; //匿名内部类的类体部分 &#125; 使用匿名内部类我们必须要继承一个父类或者实现一个接口,这是因为匿名内部类是直接使用new来生成一个对象的引用。当然这个引用是隐式的1234567891011public class Anonymous &#123; //测试匿名内部类 public static void main(String[] args) &#123; Inner inner = new Inner() &#123; @Override public String getName() &#123; return "tom"; &#125; &#125;; System.out.println(inner.getName()); 在使用匿名内部类的过程中，我们需要注意如下几点： 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。 匿名内部类中是不能定义构造函数的。 匿名内部类中不能存在任何的静态成员变量和静态方法。 匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java单例模式]]></title>
    <url>%2F2018%2F07%2F14%2Fjava%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式概述 单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例 Java中单例模式定义：“一个类有且仅有一个实例，并且自行实例化向整个系统提供。” 单例模式三要素： 私有的构造方法； 指向自己实例的私有静态引用； 以自己实例为返回值的静态的公有方法。 单例模式实现 单例模式可以分为懒汉式和饿汉式： 懒汉式单例模式：在类加载时不初始化。饿汉式单例模式：在类加载时就完成了初始化，所以类加载比较慢，但获取对象的速度快。 第一种（懒汉，线程不安全）12345678910public class SingletonDemo &#123; private static SingletonDemo instance; private SingletonDemo1()&#123;&#125; public static SingletonDemo1 getInstance()&#123; if (instance == null) &#123; instance = new SingletonDemo1(); &#125; return instance; &#125; &#125; 第二种（懒汉，线程安全）1234567891011public class SingletonDemo &#123; public class SingletonDemo &#123; private static SingletonDemo instance; private SingletonDemo2()&#123;&#125; public static synchronized SingletonDemo2 getInstance()&#123; if (instance == null) &#123; instance = new SingletonDemo2(); &#125; return instance; &#125; &#125; 第三种（饿汉）12345678public class SingletonDemo &#123; public class SingletonDemo &#123; private static SingletonDemo instance = new SingletonDemo3(); private SingletonDemo3()&#123;&#125; public static SingletonDemo3 getInstance()&#123; return instance; &#125; &#125; 单例模式优缺点 优点： 在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例 单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。 提供了对唯一实例的受控访问。 由于在系统内存中只存在一个对象，因此可以 节约系统资源，当 需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。 允许可变数目的实例。 避免对共享资源的多重占用。 缺点 不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。 由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。 单例类的职责过重，在一定程度上违背了“单一职责原则”。 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。使用场景由于单例模式具有以上优点，并且形式上比较简单，所以是日常开发中用的比较多的一种设计模式，其核心在于为整个系统提供一个唯一的实例，其应用场景包括但不仅限于以下几种： 有状态的工具类对象； 频繁访问数据库或文件的对象；我的cnds：https://blog.csdn.net/qq_38384971]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[text]]></title>
    <url>%2F2018%2F07%2F14%2Ftext%2F</url>
    <content type="text"><![CDATA[下载图片 点击加载下载文档点击下载 Think In Java在线 测试1测试2###测试3 ####测试4 代码测试public static void main(String[] args) { MyLinkList myLinkList = new MyLinkList(); for (int i = 0; i &lt; 100; i++) { myLinkList.add(i); } public static void main(String[] args) { MyLinkList myLinkList = new MyLinkList(); for (int i = 0; i &lt; 100; i++) { myLinkList.add(i);ll } 测试yLinkList.add(i); 序列测试 测试 cs 测试 测试 测试测试测试分页测试 代码类型测试12345public static void main(String[] args) &#123; MyLinkList myLinkList = new MyLinkList(); for (int i = 0; i &lt; 100; i++) &#123; myLinkList.add(i); &#125; [] [title] [url] [link text]123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*- # 定义函数def printme( str ): "打印任何传入的字符串" print str; return; # 调用函数printme("我要调用用户自定义函数!");printme("再次调用同一函数"); [] [title] [url] [link text]1234567var w=window.innerWidth|| document.documentElement.clientWidth|| document.body.clientWidth;var h=window.innerHeight|| document.documentElement.clientHeight|| document.body.clientHeight; [] [title] [url] [link text]12345678&lt;div id="bpn"&gt;&lt;ul class="prenext"&gt;&lt;li class="pre"&gt;&lt;a href="/js/js_obj_regexp.asp" title="JavaScript RegExp 对象"&gt;JS 正则表达式&lt;/a&gt;&lt;/li&gt;&lt;li class="next"&gt;&lt;a href="/js/js_window_screen.asp" title="JavaScript Window Screen"&gt;JS Screen&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt; [lang:] [title] [url] [link text]1 2018/7/14 16:55:56]]></content>
  </entry>
  <entry>
    <title><![CDATA[链表的java实现]]></title>
    <url>%2F2018%2F07%2F13%2F%E9%93%BE%E8%A1%A8%E7%9A%84java%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[创建一个节点和一个对象 节点包含两个属性：数据，和指向连接对象实现添加和查询方法 ##创建节点1234567891011121314151617181920212223public class Node &#123; private int date; private Node next; public int getDate() &#123; return date; &#125; public void setDate(int date) &#123; this.date = date; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node next) &#123; this.next = next; &#125; &#125; ##创建对象1234567891011121314151617181920212223242526272829public class MyLinkList &#123; private Node head=new Node(); private Node tail=head; //定义存放数据方法 public void add(int num)&#123; //创建一个节点，将数据填充到节点，将尾部节点指向新创建的节点 Node node=new Node(); //将数据填充节点 node.setDate(num); tail.setNext(node); tail=node; &#125; //定义get方法 public int get(int index)&#123; Node target=head; for (int i = 0; i &lt; index+1; i++) &#123; target=target.getNext(); &#125; return target.getDate(); &#125; public static void main(String[] args) &#123; MyLinkList myLinkList = new MyLinkList(); for (int i = 0; i &lt; 100; i++) &#123; myLinkList.add(i); &#125; System.out.println(myLinkList.get(1)); &#125; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
</search>
