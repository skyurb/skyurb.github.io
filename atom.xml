<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://skyurb.cn/"/>
  <updated>2018-07-23T14:05:09.350Z</updated>
  <id>http://skyurb.cn/</id>
  
  <author>
    <name>skyurb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git学习</title>
    <link href="http://skyurb.cn/2018/07/23/git%E5%AD%A6%E4%B9%A0/"/>
    <id>http://skyurb.cn/2018/07/23/git学习/</id>
    <published>2018-07-23T13:42:08.000Z</published>
    <updated>2018-07-23T14:05:09.350Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/0013848605496402772ffdb6ab448deb7eef7baa124171b000/0" alt=""></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</li></ul><ul><li>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</li></ul><ul><li>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。<a id="more"></a></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Git 目前支持 Linux/Unix、Solaris、Mac和 Windows 平台上运行。<br>Git 各平台安装包下载地址为：<a href="http://git-scm.com/downloads" target="_blank" rel="noopener">http://git-scm.com/downloads</a></p><p>liunx（Debian/Ubuntu）下下载：<br><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="built_in">get</span> install libcurl4-gnutls-<span class="built_in">dev</span> libexpat1-<span class="built_in">dev</span> gettext \</span><br><span class="line">libz-<span class="built_in">dev</span> libssl-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure></p><p>liunx（Centos/RedHat）<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get <span class="keyword">install</span> git</span><br><span class="line">yum -y <span class="keyword">install</span> git-core</span><br></pre></td></tr></table></figure></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li><p>配置个人的用户名称和电子邮件地址：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global user.name <span class="string">"yourname"</span></span><br><span class="line">git<span class="built_in"> config </span>--global user.email youremail@runoob.com</span><br></pre></td></tr></table></figure></li><li><p>查看配置信息</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--list</span><br></pre></td></tr></table></figure></li><li><p>检查版本</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="comment">--version</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.liaoxuefeng.com/cdn/files/attachments/0013848605496402772ffdb6ab448deb7eef7baa124171b000/0&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。
    
    </summary>
    
    
      <category term="git" scheme="http://skyurb.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>用HashMap实现简单的倒排索引</title>
    <link href="http://skyurb.cn/2018/07/20/%E7%94%A8HashMap%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"/>
    <id>http://skyurb.cn/2018/07/20/用HashMap实现简单的倒排索引/</id>
    <published>2018-07-20T12:46:35.000Z</published>
    <updated>2018-07-21T08:36:07.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>搜索引擎通常检索的场景是：给定几个关键词，找出包含关键词的文档<br>用HashMap实现倒排索引的设想：</p><ul><li>举例 有三本书，每本书中都会有几个关键字，通过关键字来检索到出现在那几本书中</li></ul><ul><li>实行：创建两个hashmap，一个用来存放原数据，一个用来存放新索引，以原数据的value分割后的单词做新索引的key，以原数据的value对应的key做索引value，添加到新索引中<a id="more"></a><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2></li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">       <span class="comment">//存储数据map</span></span><br><span class="line">       <span class="keyword">HashMap</span> date = <span class="keyword">new</span> <span class="keyword">HashMap</span>();</span><br><span class="line">       date.put(<span class="string">"book1"</span>,<span class="string">"hello world"</span>);</span><br><span class="line">       date.put(<span class="string">"book2"</span>,<span class="string">"hello beautiful world"</span>);</span><br><span class="line">       date.put(<span class="string">"book3"</span>,<span class="string">"hello beautiful new world"</span>);</span><br><span class="line">       <span class="comment">//索引的map</span></span><br><span class="line">       <span class="keyword">HashMap</span> index = <span class="keyword">new</span> <span class="keyword">HashMap</span>();</span><br><span class="line">       Set keySet = date.keySet();</span><br><span class="line">       <span class="comment">//遍历date的key</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">Object</span> word:keySet) &#123;</span><br><span class="line">           <span class="keyword">String</span> keyString = (<span class="keyword">String</span>) word;</span><br><span class="line">           <span class="comment">//通过key获得value</span></span><br><span class="line">           <span class="keyword">String</span> count = (<span class="keyword">String</span>) date.<span class="built_in">get</span>(keyString);</span><br><span class="line">           <span class="comment">//将字符串分割成数组</span></span><br><span class="line">           <span class="keyword">String</span>[] words = count.<span class="built_in">split</span>(<span class="string">" "</span>);</span><br><span class="line">           <span class="comment">//遍历数组，获取关键字</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;words.length ; i++) &#123;</span><br><span class="line">               <span class="comment">//判断索引中是否存在关键字，如果不存在添加，存在将追加</span></span><br><span class="line">               <span class="keyword">if</span> (!index.containsKey(words[i]))&#123;</span><br><span class="line">                   <span class="comment">//创建一个arrylist用来添加或后续追加索引值</span></span><br><span class="line">                   ArrayList books = <span class="keyword">new</span> ArrayList();</span><br><span class="line">                   <span class="comment">//将date的key存入</span></span><br><span class="line">                   books.<span class="built_in">add</span>(keyString);</span><br><span class="line">                   <span class="comment">//将新组建的键值对存入索引</span></span><br><span class="line">                   index.put(words[i],books);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//如果存在关键字,通过关键字获取value，</span></span><br><span class="line">                   List books = (List) index.<span class="built_in">get</span>(words[i]);</span><br><span class="line">                   <span class="comment">//将date的key追加到value中</span></span><br><span class="line">                   books.<span class="built_in">add</span>(keyString);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//输出新map</span></span><br><span class="line">       System.out.<span class="built_in">println</span>(index);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="keyword">beautiful=[book2, </span><span class="keyword">book3], </span>new=[<span class="keyword">book3], </span>world=[<span class="keyword">book2, </span><span class="keyword">book1, </span><span class="keyword">book3], </span>hello=[<span class="keyword">book2, </span><span class="keyword">book1, </span><span class="keyword">book3]&#125;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">Process </span>finished with exit <span class="meta">code</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;搜索引擎通常检索的场景是：给定几个关键词，找出包含关键词的文档&lt;br&gt;用HashMap实现倒排索引的设想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;举例 有三本书，每本书中都会有几个关键字，通过关键字来检索到出现在那几本书中&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;实行：创建两个hashmap，一个用来存放原数据，一个用来存放新索引，以原数据的value分割后的单词做新索引的key，以原数据的value对应的key做索引value，添加到新索引中
    
    </summary>
    
    
      <category term="java" scheme="http://skyurb.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java基础笔记整理</title>
    <link href="http://skyurb.cn/2018/07/19/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    <id>http://skyurb.cn/2018/07/19/java基础笔记整理/</id>
    <published>2018-07-19T11:04:08.000Z</published>
    <updated>2018-07-21T08:36:07.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java基础易错知识整理"><a href="#java基础易错知识整理" class="headerlink" title="java基础易错知识整理"></a>java基础易错知识整理</h1><h2 id="数组初始值"><a href="#数组初始值" class="headerlink" title="数组初始值"></a>数组初始值</h2><p>下面代码输出结果是0<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">int</span>[] arry=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">             Sysout.out.println(arr[i]);</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure></p><p>–int类型：0</p><p>–short类型：(short）0</p><p>–byte类型：(byte）0</p><p>–long类型：0L</p><p>–doulbe类型：0.0d</p><p>–float类型：0.0f</p><p>–char类型：\u0000（空格字符）</p><p>–boolean类型：false<br>–引用类型的数组在创建之后，赋默认值null<br><a id="more"></a></p><h2 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h2><p>抛出异常有三种形式，一是throw,一个throws，还有一种系统自动抛异常。下面它们之间的异同</p><ol><li><p>当程序语句出现一些逻辑错误、主义错误或类型转换错误时，系统会自动抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>, b =<span class="number">0</span>; </span><br><span class="line">    System.out.println(<span class="number">5</span>/b); </span><br><span class="line">    <span class="comment">//function(); </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>throw是语句抛出一个异常，一般是在代码块的内部，当程序出现某种逻辑错误时由程序员主动抛出某种特定类型的异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    String s = <span class="string">"abc"</span>; </span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">"abc"</span>)) &#123; </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      System.out.println(s); </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>throws是方法可能抛出异常的声明。(用在声明方法时，表示该方法可能要抛出异常)</p><p>public void function() throws Exception{……}</p></li></ol><p>当某个方法可能会抛出某种异常时用于throws 声明可能抛出的异常，然后交给上层调用它的方法程序处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> class <span class="title">testThrows</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> <span class="keyword">throws</span> NumberFormatException</span>&#123; </span><br><span class="line">String s = <span class="string">"abc"</span>; </span><br><span class="line">System.out.println(Double.parseDouble(s)); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">function(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123; </span><br><span class="line">System.err.println(<span class="string">"非数据类型不能强制类型转换。"</span>); </span><br><span class="line"><span class="comment">//e.printStackTrace(); </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>throw与throws的比较<br>1、throws出现在方法函数头；而throw出现在函数体。<br>2、throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。<br>3、两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。<br><em>参考自 ：</em><a href="https://blog.csdn.net/hjfcgt123/article/details/53349275" target="_blank" rel="noopener">https://blog.csdn.net/hjfcgt123/article/details/53349275</a></p><h2 id="堆溢出和栈溢出"><a href="#堆溢出和栈溢出" class="headerlink" title="堆溢出和栈溢出"></a>堆溢出和栈溢出</h2><ol><li>栈溢出(StackOverflowError)</li><li>堆溢出(OutOfMemoryError:java heap space)<br>先了解一下java中的堆和栈，JAVA在程序运行时，在内存中划分5片空间进行数据的存储。分别是：1：寄存器。2：本地方法区。3：方法区。4：栈。5：堆。</li></ol><p>基本数据类型、局部变量都是存放在栈内存中的，用完就消失。<br>new创建的实例化对象及数组，是存放在堆内存中的，用完之后靠垃圾回收机制不定期自动消除。举个例子<br>ArrayList list = new ArrayList();</p><p>实际上，在创建完上面的一个对象后，在JVM中，会把new出来的对象存放在堆内存中，</p><p>同时，在方法栈中存放着对象的引用关系。</p><ul><li>如果想要堆溢出，比较简单，可以循环创建对象或大的对象；死循环创建字符串对象或字符串拼接。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">      ArrayList list=<span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">          list.add(<span class="keyword">new</span> Heap());</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>如果想要栈溢出，可以递归调用方法，这样随着栈深度的增加，JVM 维持着一条长长的方法调用轨迹，直到内存不够分配，产生栈溢出。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> Stack().test();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">      test();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="String和StringBuffer，StringBuilder区别"><a href="#String和StringBuffer，StringBuilder区别" class="headerlink" title="String和StringBuffer，StringBuilder区别"></a>String和StringBuffer，StringBuilder区别</h2><p>这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面</p><ol><li>首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String<br>String最慢的原因：<br><strong><br>　　**</strong>String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。**<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">              String str=<span class="string">"abc"</span>;</span><br><span class="line">              System.out.println(str);</span><br><span class="line">              str=str+<span class="string">"de"</span>;</span><br><span class="line">              System.out.println(str);</span><br></pre></td></tr></table></figure>如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。</li></ol><p>而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">               String str=<span class="string">"abc"</span>+<span class="string">"de"</span>;</span><br><span class="line">               StringBuilder stringBuilder=<span class="keyword">new</span> StringBuilder().append(<span class="string">"abc"</span>).append(<span class="string">"de"</span>);</span><br><span class="line">               System.out.println(str);</span><br><span class="line">               System.out.println(stringBuilder.toString());</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure><br>这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多</p><ol start="2"><li>在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的<blockquote><p>如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。<br><em>来自：</em><a href="https://www.cnblogs.com/su-feng/p/6659064.html" target="_blank" rel="noopener">https://www.cnblogs.com/su-feng/p/6659064.html</a></p></blockquote><h2 id="Java中-号与equals-方法的区别"><a href="#Java中-号与equals-方法的区别" class="headerlink" title="Java中==号与equals()方法的区别"></a>Java中==号与equals()方法的区别</h2></li></ol><ul><li>首先==号在比较基本数据类型时比较的是值，而用==号比较两个对象时比较的是两个对象的地址值：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">               <span class="keyword">int</span> y = <span class="number">10</span>;</span><br><span class="line">               String str1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">               String str2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">               System.out.println(x == y); <span class="comment">// 输出true</span></span><br><span class="line">               System.out.println(str1 == str2); <span class="comment">// 输出false </span></span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>Equals是object中的方法，用于判断两个对象是否想等。默认的equals是== ,不过子类可以重写父类的方法，加以改变。典型如string integer等类都重写了equals方法<h2 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h2></li><li>一个是Array(动态数组)的数据结构，一个是Link(链表)的数据结构，此外，它们两个都是对List接口的实现。<br>前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列</li><li>当随机访问List时（get和set操作），ArrayList比LinkedList的效率更高，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找</li><li>当对数据进行增加和删除的操作时(add和remove操作)，LinkedList比ArrayList的效率更高，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动</li><li>从利用效率来看，ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。</li><li>ArrayList主要控件开销在于需要在List列表预留一定空间；而LinkList主要控件开销在于需要存储结点信息以及结点指针信息。<br><em>来自于：</em><a href="https://www.cnblogs.com/Amedeo/p/7885146.html" target="_blank" rel="noopener">https://www.cnblogs.com/Amedeo/p/7885146.html</a><h2 id="运行时异常和受检时异常区别"><a href="#运行时异常和受检时异常区别" class="headerlink" title="运行时异常和受检时异常区别"></a>运行时异常和受检时异常区别</h2>最本质的区别是RuntimeException是运行时才会发生的异常, 而受检查异常是编译时异常,编译器会分析哪些异常会在执行一个方法或者构造函数的时候抛出。 </li><li>运行时异常（RuntimeException）也称作未检测的异常（unchecked exception），这表示这种异常不需要编译器来检测。RuntimeException是所有可以在运行时抛出的异常的父类。一个方法除要捕获异常外，如果它执行的时候可能会抛出RuntimeException的子类，那么它就不需要用throw语句来声明抛出的异常</li><li>受检查异常（checked exception）都是编译器在编译时进行校验的，通过throws语句或者try{}cathch{} 语句块来处理检测异常。编译器会分析哪些异常会在执行一个方法或者构造函数的时候抛出。<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>………</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java基础易错知识整理&quot;&gt;&lt;a href=&quot;#java基础易错知识整理&quot; class=&quot;headerlink&quot; title=&quot;java基础易错知识整理&quot;&gt;&lt;/a&gt;java基础易错知识整理&lt;/h1&gt;&lt;h2 id=&quot;数组初始值&quot;&gt;&lt;a href=&quot;#数组初始值&quot; class=&quot;headerlink&quot; title=&quot;数组初始值&quot;&gt;&lt;/a&gt;数组初始值&lt;/h2&gt;&lt;p&gt;下面代码输出结果是0&lt;br&gt; &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] arry=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             Sysout.out.println(arr[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;–int类型：0&lt;/p&gt;
&lt;p&gt;–short类型：(short）0&lt;/p&gt;
&lt;p&gt;–byte类型：(byte）0&lt;/p&gt;
&lt;p&gt;–long类型：0L&lt;/p&gt;
&lt;p&gt;–doulbe类型：0.0d&lt;/p&gt;
&lt;p&gt;–float类型：0.0f&lt;/p&gt;
&lt;p&gt;–char类型：\u0000（空格字符）&lt;/p&gt;
&lt;p&gt;–boolean类型：false&lt;br&gt;–引用类型的数组在创建之后，赋默认值null&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://skyurb.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>字符编码</title>
    <link href="http://skyurb.cn/2018/07/18/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    <id>http://skyurb.cn/2018/07/18/字符编码/</id>
    <published>2018-07-18T01:29:13.000Z</published>
    <updated>2018-07-21T08:36:07.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用字符编码分类"><a href="#常用字符编码分类" class="headerlink" title="常用字符编码分类"></a>常用字符编码分类</h2><ul><li>字符集编码：就是用数字来表示各种字符</li><li>asc码：美国国家标准码<br>一个字节表示一个字符</li><li>UTF：unicode世界范围的统一编码<br>用四个字节表示一个字符<br>UTF-8:优化以后的utf码。让英文语系的编码量明显减少，有保证了世界范围的通用</li><li>GBK：汉字内码扩展规范</li><li>Big5：在台湾、香港与澳门地区，使用的是繁体中文字符集<a id="more"></a><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li></ul><p>1、编码界最初只有ASCII码，只用了1byte中的7bit（0~127）；</p><p>2、欧洲人发现128个不够了，就把1byte中没用的最高位给用上了，出现了Latin系列（ISO-8859系列）编码；</p><p>3、中国人民通过对ASCII编码进行中文扩充改造，产生了GB2312编码，可以表示6000多个常用汉字；</p><p>4、汉字实在太多了，还有繁体、各种字符呀，于是加以扩展，有了GBK；</p><p>5、GBK还不够，少数民族的字还木有呀，于是GBK又扩展为GB18030；</p><p>6、每个国家、语言都有自己的编码，彼此无法交流，迫切需要大一统局面的出现；</p><p>7、Unicode诞生，可以容纳全世界的任何文字。Unicode分为UCS-2和UCS-4，分别是2字节和4字节，实际2字节就够用了；</p><p>8、为了Unicode能实际应用（存储、传输），制定了Unicode的编码方式，即UTF，有UTF-8、UTF-16、UTF-32，其中UTF-8应用广泛；</p><p>9、UTF-16、UTF-32均是多字节传输，存在字节顺序的问题，于是有了大头还是小头的概念，为了解决这个问题，引入了BOM。UTF-8是单字节传输，不存在这个问题，也就不需要BOM，但可以有，仅用来表明编码格式；</p><p>10、要从“环境/终端/文本/程序”等不同层次去理解编码，并尝试解决遇到的问题；</p><p><em>在线编码转换工具</em><a href="http://tool.chinaz.com/Tools/Unicode.aspx" target="_blank" rel="noopener">http://tool.chinaz.com/Tools/Unicode.aspx</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;常用字符编码分类&quot;&gt;&lt;a href=&quot;#常用字符编码分类&quot; class=&quot;headerlink&quot; title=&quot;常用字符编码分类&quot;&gt;&lt;/a&gt;常用字符编码分类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;字符集编码：就是用数字来表示各种字符&lt;/li&gt;
&lt;li&gt;asc码：美国国家标准码&lt;br&gt;一个字节表示一个字符&lt;/li&gt;
&lt;li&gt;UTF：unicode世界范围的统一编码&lt;br&gt;用四个字节表示一个字符&lt;br&gt;UTF-8:优化以后的utf码。让英文语系的编码量明显减少，有保证了世界范围的通用&lt;/li&gt;
&lt;li&gt;GBK：汉字内码扩展规范&lt;/li&gt;
&lt;li&gt;Big5：在台湾、香港与澳门地区，使用的是繁体中文字符集
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>内部类</title>
    <link href="http://skyurb.cn/2018/07/16/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://skyurb.cn/2018/07/16/内部类/</id>
    <published>2018-07-16T01:42:07.000Z</published>
    <updated>2018-07-21T08:36:07.194Z</updated>
    
    <content type="html"><![CDATA[<p>#定义：在一个类的内部又定义了一个类，这就是内部类。#<br>举例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String outerName;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> outerAge;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> String innerName;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> innerAge;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>内部类是一个编译时概念，编译后外部类及其内部类会生成两个独立的class文件： OuterClass.class和OuterClass$InnerClass.class<br>内部类可以直接访问外部类的元素，但是外部类不可以直接访问内部类的元素<br><a id="more"></a></p><h2 id="表现形式"><a href="#表现形式" class="headerlink" title="表现形式"></a>表现形式</h2><ol><li>静态内部类<blockquote><p>关键字static可以修饰成员变量、方法、代码块，其实它还可以修饰内部类，使用static修饰的内部类我们称之为静态内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：</p></blockquote></li></ol><p>静态内部类的创建是不需要依赖于外围类，可以直接创建<br>静态内部类不可以使用任何外围类的非static成员变量和方法，而内部类则都可以</p><ol start="2"><li>成员内部类<blockquote><p>成员内部类也是最普通的内部类，它是外部类的一个成员，所以他是可以无限制的访问外围类的所有成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。</p></blockquote></li></ol><p>在成员内部类中要注意两点：</p><p>成员内部类中不能存在任何static的变量和方法<br>成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类</p><ol start="3"><li>局部内部类<blockquote><p>有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。</p></blockquote></li><li>匿名内部类<blockquote><p>匿名内部类其实就是一个没有名字的方法内部类，所以它符合方法内部类的所有约束，初次之外，还有一些地方需要注意：</p></blockquote></li></ol><p>匿名内部类是没有访问修饰符的。<br>匿名内部类必须继承一个抽象类或者实现一个接口<br>匿名内部类中不能存在任何静态成员或方法<br>匿名内部类是没有构造方法的，因为它没有类名。<br>一般使用匿名内部类的场景是，要继承或实现的接口只有一个抽象方法，比如添加一个监听器</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><em>为什么要使用内部类？在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</em><br>⒈ 内部类对象可以访问创建它的对象的实现，包括私有数据；<br>⒉ 内部类不为同一包的其他类所见，具有很好的封装性；<br>⒊ 使用内部类可以很方便的编写事件驱动程序；<br>⒋ 匿名内部类可以方便的定义运行时回调；<br>5.内部类可以方便的定义</p><hr><h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><p>匿名内部类的创建方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类构造器（参数列表）|实现接口（）  </span><br><span class="line">   &#123;  </span><br><span class="line">   <span class="comment">//匿名内部类的类体部分  </span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>使用匿名内部类我们必须要继承一个父类或者实现一个接口,这是因为匿名内部类是直接使用new来生成一个对象的引用。当然这个引用是隐式的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Anonymous</span> </span>&#123;</span><br><span class="line">  <span class="comment">//测试匿名内部类</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Inner inner = <span class="keyword">new</span> Inner() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">"tom"</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      System.out.println(inner.getName());</span><br></pre></td></tr></table></figure></p><p>  在使用匿名内部类的过程中，我们需要注意如下几点：</p><ul><li>使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。</li></ul><ul><li>匿名内部类中是不能定义构造函数的。</li></ul><ul><li>匿名内部类中不能存在任何的静态成员变量和静态方法。</li></ul><ul><li>匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。</li></ul><ul><li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#定义：在一个类的内部又定义了一个类，这就是内部类。#&lt;br&gt;举例：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;OuterClass&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String outerName;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; outerAge;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;InnerClass&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String innerName;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; innerAge;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;内部类是一个编译时概念，编译后外部类及其内部类会生成两个独立的class文件： OuterClass.class和OuterClass$InnerClass.class&lt;br&gt;内部类可以直接访问外部类的元素，但是外部类不可以直接访问内部类的元素&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://skyurb.cn/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://skyurb.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java单例模式</title>
    <link href="http://skyurb.cn/2018/07/14/java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://skyurb.cn/2018/07/14/java单例模式/</id>
    <published>2018-07-14T07:09:33.000Z</published>
    <updated>2018-07-21T08:36:07.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式概述"><a href="#单例模式概述" class="headerlink" title="单例模式概述"></a>单例模式概述</h1><blockquote><p>单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例</p></blockquote><blockquote><p>Java中单例模式定义：“一个类有且仅有一个实例，并且自行实例化向整个系统提供。”</p></blockquote><blockquote><p>单例模式三要素：</p></blockquote><ul><li>私有的构造方法；</li><li>指向自己实例的私有静态引用；</li><li>以自己实例为返回值的静态的公有方法。</li></ul><a id="more"></a><h1 id="单例模式实现"><a href="#单例模式实现" class="headerlink" title="单例模式实现"></a>单例模式实现</h1><blockquote><p>单例模式可以分为懒汉式和饿汉式：</p><blockquote><p>懒汉式单例模式：在类加载时不初始化。<br>饿汉式单例模式：在类加载时就完成了初始化，所以类加载比较慢，但获取对象的速度快。</p></blockquote></blockquote><h3 id="第一种（懒汉，线程不安全）"><a href="#第一种（懒汉，线程不安全）" class="headerlink" title="第一种（懒汉，线程不安全）"></a>第一种（懒汉，线程不安全）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">           instance = <span class="keyword">new</span> SingletonDemo1();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="第二种（懒汉，线程安全）"><a href="#第二种（懒汉，线程安全）" class="headerlink" title="第二种（懒汉，线程安全）"></a>第二种（懒汉，线程安全）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonDemo2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">           instance = <span class="keyword">new</span> SingletonDemo2();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="第三种（饿汉）"><a href="#第三种（饿汉）" class="headerlink" title="第三种（饿汉）"></a>第三种（饿汉）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance = <span class="keyword">new</span> SingletonDemo3();</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo3 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="单例模式优缺点"><a href="#单例模式优缺点" class="headerlink" title="单例模式优缺点"></a>单例模式优缺点</h1><blockquote><p>优点：</p></blockquote><ol><li>在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例</li><li>单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。</li><li>提供了对唯一实例的受控访问。</li><li>由于在系统内存中只存在一个对象，因此可以 节约系统资源，当 需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。</li><li>允许可变数目的实例。 </li><li>避免对共享资源的多重占用。</li></ol><blockquote><p>缺点</p></blockquote><ol><li>不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。 </li><li>由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。 </li><li>单例类的职责过重，在一定程度上违背了“单一职责原则”。 </li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1>由于单例模式具有以上优点，并且形式上比较简单，所以是日常开发中用的比较多的一种设计模式，其核心在于为整个系统提供一个唯一的实例，其应用场景包括但不仅限于以下几种：</li></ol><ul><li>有状态的工具类对象；</li><li>频繁访问数据库或文件的对象；<br>我的cnds：<a href="https://blog.csdn.net/qq_38384971" title="cnds" target="_blank" rel="noopener">https://blog.csdn.net/qq_38384971</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;单例模式概述&quot;&gt;&lt;a href=&quot;#单例模式概述&quot; class=&quot;headerlink&quot; title=&quot;单例模式概述&quot;&gt;&lt;/a&gt;单例模式概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Java中单例模式定义：“一个类有且仅有一个实例，并且自行实例化向整个系统提供。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;单例模式三要素：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;私有的构造方法；&lt;/li&gt;
&lt;li&gt;指向自己实例的私有静态引用；&lt;/li&gt;
&lt;li&gt;以自己实例为返回值的静态的公有方法。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://skyurb.cn/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://skyurb.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>text</title>
    <link href="http://skyurb.cn/2018/07/14/text/"/>
    <id>http://skyurb.cn/2018/07/14/text/</id>
    <published>2018-07-14T03:50:13.000Z</published>
    <updated>2018-07-21T08:36:07.190Z</updated>
    
    <content type="html"><![CDATA[<p>下载图片<br> <a href="/download/zz.jpg">点击加载</a><br>下载文档<br><a href="/download/java基础.docx">点击下载</a></p><p><a href="/download/Think In Java 4.pdf">Think In Java在线</a></p><h1 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h1><h2 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h2><p>###测试3</p><p>####测试4</p><h2 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h2><pre><code>public static void main(String[] args) {            MyLinkList myLinkList = new MyLinkList();            for (int i = 0; i &lt; 100; i++) {                myLinkList.add(i);            }</code></pre><p><code>public static void main(String[] args) {         MyLinkList myLinkList = new MyLinkList();         for (int i = 0; i &lt; 100; i++) {         myLinkList.add(i);ll          }</code> </p><blockquote><p>测试yLinkList.add(i);</p></blockquote><h2 id="序列测试"><a href="#序列测试" class="headerlink" title="序列测试"></a>序列测试</h2><ul><li>测试</li><li>cs</li><li>测试</li></ul><ol><li>测试</li><li>测试<br><strong>测试</strong><br><em>测试</em><h2 id="分页测试"><a href="#分页测试" class="headerlink" title="分页测试"></a>分页测试</h2><a id="more"></a><h2 id="代码类型测试"><a href="#代码类型测试" class="headerlink" title="代码类型测试"></a>代码类型测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">               MyLinkList myLinkList = <span class="keyword">new</span> MyLinkList();</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                   myLinkList.add(i);</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight python"><figcaption><span>[] [title] [url] [link text]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span><span class="params">( str )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="keyword">print</span> str;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">printme(<span class="string">"我要调用用户自定义函数!"</span>);</span><br><span class="line">printme(<span class="string">"再次调用同一函数"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><figcaption><span>[] [title] [url] [link text]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w=<span class="built_in">window</span>.innerWidth</span><br><span class="line">|| <span class="built_in">document</span>.documentElement.clientWidth</span><br><span class="line">|| <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h=<span class="built_in">window</span>.innerHeight</span><br><span class="line">|| <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">|| <span class="built_in">document</span>.body.clientHeight;</span><br></pre></td></tr></table></figure><figure class="highlight html"><figcaption><span>[] [title] [url] [link text]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bpn"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"prenext"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"pre"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/js/js_obj_regexp.asp"</span> <span class="attr">title</span>=<span class="string">"JavaScript RegExp 对象"</span>&gt;</span>JS 正则表达式<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"next"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/js/js_window_screen.asp"</span> <span class="attr">title</span>=<span class="string">"JavaScript Window Screen"</span>&gt;</span>JS Screen<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>[lang:] [title] [url] [link text]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><hr><p>2018/7/14 16:55:56 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下载图片&lt;br&gt; &lt;a href=&quot;/download/zz.jpg&quot;&gt;点击加载&lt;/a&gt;&lt;br&gt;下载文档&lt;br&gt;&lt;a href=&quot;/download/java基础.docx&quot;&gt;点击下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/download/Think In Java 4.pdf&quot;&gt;Think In Java在线&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;测试1&quot;&gt;&lt;a href=&quot;#测试1&quot; class=&quot;headerlink&quot; title=&quot;测试1&quot;&gt;&lt;/a&gt;测试1&lt;/h1&gt;&lt;h2 id=&quot;测试2&quot;&gt;&lt;a href=&quot;#测试2&quot; class=&quot;headerlink&quot; title=&quot;测试2&quot;&gt;&lt;/a&gt;测试2&lt;/h2&gt;&lt;p&gt;###测试3&lt;/p&gt;
&lt;p&gt;####测试4&lt;/p&gt;
&lt;h2 id=&quot;代码测试&quot;&gt;&lt;a href=&quot;#代码测试&quot; class=&quot;headerlink&quot; title=&quot;代码测试&quot;&gt;&lt;/a&gt;代码测试&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
            MyLinkList myLinkList = new MyLinkList();
            for (int i = 0; i &amp;lt; 100; i++) {
                myLinkList.add(i);
            }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;public static void main(String[] args) {
         MyLinkList myLinkList = new MyLinkList();
         for (int i = 0; i &amp;lt; 100; i++) {
         myLinkList.add(i);ll
          }&lt;/code&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;测试yLinkList.add(i);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;序列测试&quot;&gt;&lt;a href=&quot;#序列测试&quot; class=&quot;headerlink&quot; title=&quot;序列测试&quot;&gt;&lt;/a&gt;序列测试&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;li&gt;cs&lt;/li&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;li&gt;测试&lt;br&gt;&lt;strong&gt;测试&lt;/strong&gt;&lt;br&gt;&lt;em&gt;测试&lt;/em&gt;&lt;h2 id=&quot;分页测试&quot;&gt;&lt;a href=&quot;#分页测试&quot; class=&quot;headerlink&quot; title=&quot;分页测试&quot;&gt;&lt;/a&gt;分页测试&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>链表的java实现</title>
    <link href="http://skyurb.cn/2018/07/13/%E9%93%BE%E8%A1%A8%E7%9A%84java%E5%AE%9E%E7%8E%B0/"/>
    <id>http://skyurb.cn/2018/07/13/链表的java实现/</id>
    <published>2018-07-13T12:37:07.000Z</published>
    <updated>2018-07-21T08:36:07.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建一个节点和一个对象"><a href="#创建一个节点和一个对象" class="headerlink" title="创建一个节点和一个对象"></a>创建一个节点和一个对象</h2><blockquote><p>节点包含两个属性：数据，和指向连接<br>对象实现添加和查询方法</p></blockquote><a id="more"></a><p>##创建节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">int</span> date;</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> date;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(<span class="keyword">int</span> date)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">this</span>.date = date;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> Node <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> next;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Node next)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">this</span>.next = next;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>##创建对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLinkList</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> Node head=<span class="keyword">new</span> Node();</span><br><span class="line">            <span class="keyword">private</span> Node tail=head;</span><br><span class="line">            <span class="comment">//定义存放数据方法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">                <span class="comment">//创建一个节点，将数据填充到节点，将尾部节点指向新创建的节点</span></span><br><span class="line">                Node node=<span class="keyword">new</span> Node();</span><br><span class="line">                <span class="comment">//将数据填充节点</span></span><br><span class="line">                node.setDate(num);</span><br><span class="line">            tail.setNext(node);</span><br><span class="line">                tail=node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//定义get方法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">                Node target=head;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index+<span class="number">1</span>; i++) &#123;</span><br><span class="line">                    target=target.getNext();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> target.getDate();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                MyLinkList myLinkList = <span class="keyword">new</span> MyLinkList();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    myLinkList.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(myLinkList.get(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建一个节点和一个对象&quot;&gt;&lt;a href=&quot;#创建一个节点和一个对象&quot; class=&quot;headerlink&quot; title=&quot;创建一个节点和一个对象&quot;&gt;&lt;/a&gt;创建一个节点和一个对象&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;节点包含两个属性：数据，和指向连接&lt;br&gt;对象实现添加和查询方法&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://skyurb.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="java" scheme="http://skyurb.cn/tags/java/"/>
    
      <category term="链表" scheme="http://skyurb.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
